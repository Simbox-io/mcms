// app/api/comments/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function POST(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { content, postId, fileId, projectId, pageId, parentId, tutorialId } = await request.json();

  try {
    const newComment = await prisma.comment.create({
      data: {
        content,
        author: { connect: { id: userObj.id } },
        post: postId ? { connect: { id: postId } } : undefined,
        file: fileId ? { connect: { id: fileId } } : undefined,
        project: projectId ? { connect: { id: projectId } } : undefined,
        page: pageId ? { connect: { id: pageId } } : undefined,
        parent: parentId ? { connect: { id: parentId } } : undefined,
        tutorial: tutorialId ? { connect: { id: tutorialId } } : undefined,
      },
    });
    return NextResponse.json(newComment, { status: 201 });
  } catch (error) {
    console.error('Error creating comment:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/comments/[id]/reactions/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const commentId = params.id;

  try {
    const reactions = await prisma.commentReaction.findMany({
      where: { commentId },
      include: {
        user: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
      },
    });

    return NextResponse.json(reactions);
  } catch (error) {
    console.error('Error fetching comment reactions:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const commentId = params.id;
  const { type } = await request.json();

  try {
    const existingReaction = await prisma.commentReaction.findUnique({
      where: {
        userId_commentId: {
          commentId,
          userId: userObj.id,
        },
      },
    });

    if (existingReaction) {
      await prisma.commentReaction.delete({
        where: {
          id: existingReaction.id,
        },
      });
      return NextResponse.json({ message: 'Reaction removed successfully' });
    } else {
      const newReaction = await prisma.commentReaction.create({
        data: {
          type,
          comment: { connect: { id: commentId } },
          user: { connect: { id: userObj.id } },
        },
        include: {
          user: {
            select: {
              id: true,
              username: true,
              avatar: true,
            },
          },
        },
      });
      return NextResponse.json(newReaction, { status: 201 });
    }
  } catch (error) {
    console.error('Error creating comment reaction:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const commentId = params.id;
  const { content, settings } = await request.json();

  try {
    const comment = await prisma.comment.findUnique({
      where: { id: commentId },
      include: { author: true },
    });

    if (!comment) {
      return NextResponse.json({ message: 'Comment not found' }, { status: 404 });
    }

    if (comment.author.id !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    const updatedComment = await prisma.comment.update({
      where: { id: commentId },
      data: {
        content,
        settings: settings
          ? {
              update: {
                moderationSettings: settings.moderationSettings
                  ? {
                      update: {
                        preModeration: settings.moderationSettings.preModeration,
                        postModeration: settings.moderationSettings.postModeration,
                      },
                    }
                  : undefined,
                threadingSettings: settings.threadingSettings
                  ? {
                      update: {
                        allowNesting: settings.threadingSettings.allowNesting,
                        maxDepth: settings.threadingSettings.maxDepth,
                      },
                    }
                  : undefined,
                votingSettings: settings.votingSettings
                  ? {
                      update: {
                        allowVoting: settings.votingSettings.allowVoting,
                        hideThreshold: settings.votingSettings.hideThreshold,
                      },
                    }
                  : undefined,
              },
            }
          : undefined,
      },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        post: true,
        file: true,
        project: true,
        page: true,
        parent: true,
        children: true,
        reactions: true,
        tutorial: true,
        settings: {
          include: {
            moderationSettings: true,
            threadingSettings: true,
            votingSettings: true,
          },
        },
      },
    });

    return NextResponse.json(updatedComment);
  } catch (error) {
    console.error('Error updating comment:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const commentId = params.id;

  try {
    const comment = await prisma.comment.findUnique({
      where: { id: commentId },
      include: { author: true },
    });

    if (!comment) {
      return NextResponse.json({ message: 'Comment not found' }, { status: 404 });
    }

    if (comment.author.id !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    await prisma.comment.delete({
      where: { id: commentId },
    });

    return NextResponse.json({ message: 'Comment deleted successfully' });
  } catch (error) {
    console.error('Error deleting comment:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

// app/api/posts/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getSession } from '@/lib/auth';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '1');
  const perPage = 10;

  try {
    const totalPosts = await prisma.post.count();
    const totalPages = Math.ceil(totalPosts / perPage);

    const posts = await prisma.post.findMany({
      skip: (page - 1) * perPage,
      take: perPage,
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        tags: true,
        comments: true,
        bookmarks: true,
        settings: true,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ posts, totalPages });
  } catch (error) {
    console.error('Error fetching posts:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  const session = await getSession(request);
  const user = session?.user as User;

  if (!session) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { title, content, tags, settings } = await request.json();

  try {
    const newPost = await prisma.post.create({
      data: {
        title,
        content,
        author: {
          connect: {
            id: user.id,
          },
        },
        tags: {
          connectOrCreate: tags.map((tag: string) => ({
            where: { name: tag },
            create: { name: tag },
          })),
        },
        settings: settings
          ? {
              create: {
                defaultVisibility: settings.defaultVisibility,
                commentSettings: settings.commentSettings
                  ? {
                      create: {
                        allowComments: settings.commentSettings.allowComments,
                        moderateComments: settings.commentSettings.moderateComments,
                        comment: settings.commentSettings.comment,
                      },
                    }
                  : undefined,
                sharingSettings: settings.sharingSettings
                  ? {
                      create: {
                        allowSharing: settings.sharingSettings.allowSharing,
                        sharePlatforms: settings.sharingSettings.sharePlatforms,
                      },
                    }
                  : undefined,
                revisionHistorySettings: settings.revisionHistorySettings
                  ? {
                      create: {
                        revisionsToKeep: settings.revisionHistorySettings.revisionsToKeep,
                      },
                    }
                  : undefined,
              },
            }
          : undefined,
      },
    });

    return NextResponse.json(newPost, { status: 201 });
  } catch (error) {
    console.error('Error creating post:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/posts/[id]/comments/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const postId = params.id;

  try {
    const comments = await prisma.comment.findMany({
      where: { postId },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        reactions: true,
      },
    });

    return NextResponse.json(comments);
  } catch (error) {
    console.error('Error fetching post comments:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const postId = params.id;
  const { content, parentId } = await request.json();

  try {
    const newComment = await prisma.comment.create({
      data: {
        content,
        author: { connect: { id: userObj.id } },
        post: { connect: { id: postId } },
        parent: parentId ? { connect: { id: parentId } } : undefined,
      },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        reactions: true,
      },
    });

    return NextResponse.json(newComment, { status: 201 });
  } catch (error) {
    console.error('Error creating post comment:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/posts/[id]/tags/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const postId = params.id;

  try {
    const tags = await prisma.tag.findMany({
      where: {
        posts: {
          some: {
            id: postId,
          },
        },
      },
    });

    return NextResponse.json(tags);
  } catch (error) {
    console.error('Error fetching post tags:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const postId = params.id;
  const { tags } = await request.json();

  try {
    const post = await prisma.post.findUnique({
      where: { id: postId },
      include: { author: true },
    });

    if (!post) {
      return NextResponse.json({ message: 'Post not found' }, { status: 404 });
    }

    if (post.author.id !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    const updatedPost = await prisma.post.update({
      where: { id: postId },
      data: {
        tags: {
          connectOrCreate: tags.map((tag: string) => ({
            where: { name: tag },
            create: { name: tag },
          })),
        },
      },
      include: {
        tags: true,
      },
    });

    return NextResponse.json(updatedPost);
  } catch (error) {
    console.error('Error adding post tags:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/posts/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getSession } from '@/lib/auth';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const postId = params.id;

  try {
    const post = await prisma.post.findUnique({
      where: {
        id: postId,
      },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        tags: true,
        comments: true,
        bookmarks: true,
        settings: {
          include: {
            commentSettings: true,
            sharingSettings: true,
            revisionHistorySettings: true,
          },
        },
      },
    });

    if (!post) {
      return NextResponse.json({ message: 'Post not found' }, { status: 404 });
    }

    return NextResponse.json(post);
  } catch (error) {
    console.error('Error fetching post:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  const postId = params.id;
  const session = await getSession(request);
  const user = session?.user as User;

  if (!session) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { title, content, tags, settings } = await request.json();

  try {
    const post = await prisma.post.findUnique({
      where: { id: postId },
      include: { author: true },
    });

    if (!post) {
      return NextResponse.json({ message: 'Post not found' }, { status: 404 });
    }

    if (post.author.id !== user.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    const updatedPost = await prisma.post.update({
      where: { id: postId },
      data: {
        title,
        content,
        tags: {
          set: tags.map((tag: string) => ({ name: tag })),
        },
        settings: settings
          ? {
              update: {
                defaultVisibility: settings.defaultVisibility,
                commentSettings: settings.commentSettings
                  ? {
                      update: {
                        allowComments: settings.commentSettings.allowComments,
                        moderateComments: settings.commentSettings.moderateComments,
                      },
                    }
                  : undefined,
                sharingSettings: settings.sharingSettings
                  ? {
                      update: {
                        allowSharing: settings.sharingSettings.allowSharing,
                        sharePlatforms: settings.sharingSettings.sharePlatforms,
                      },
                    }
                  : undefined,
                revisionHistorySettings: settings.revisionHistorySettings
                  ? {
                      update: {
                        revisionsToKeep: settings.revisionHistorySettings.revisionsToKeep,
                      },
                    }
                  : undefined,
              },
            }
          : undefined,
      },
    });

    return NextResponse.json(updatedPost);
  } catch (error) {
    console.error('Error updating post:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  const postId = params.id;
  const session = await getSession(request);
  const user = session?.user as User;

  if (!session) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  try {
    const post = await prisma.post.findUnique({
      where: { id: postId },
      include: { author: true },
    });

    if (!post) {
      return NextResponse.json({ message: 'Post not found' }, { status: 404 });
    }

    if (post.author.id !== user.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    await prisma.post.delete({
      where: { id: postId },
    });

    return NextResponse.json({ message: 'Post deleted successfully' });
  } catch (error) {
    console.error('Error deleting post:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/prerequisites/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const prerequisiteId = params.id;

  try {
    const prerequisite = await prisma.prerequisite.findUnique({
      where: { id: prerequisiteId },
      include: {
        requiredTutorial: true,
      },
    });

    if (!prerequisite) {
      return NextResponse.json({ message: 'Prerequisite not found' }, { status: 404 });
    }

    return NextResponse.json(prerequisite);
  } catch (error) {
    console.error('Error fetching prerequisite:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const prerequisiteId = params.id;
  const { requiredKnowledge, requiredTutorialId } = await request.json();

  try {
    const prerequisite = await prisma.prerequisite.findUnique({
      where: { id: prerequisiteId },
      include: {
        tutorialSettings: {
          include: {
            tutorial: {
              include: {
                author: true,
              },
            },
          },
        },
      },
    });

    if (!prerequisite) {
      return NextResponse.json({ message: 'Prerequisite not found' }, { status: 404 });
    }

    if (prerequisite.tutorialSettings.tutorial.author.id !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    const updatedPrerequisite = await prisma.prerequisite.update({
      where: { id: prerequisiteId },
      data: {
        requiredKnowledge,
        requiredTutorial: requiredTutorialId
          ? { connect: { id: requiredTutorialId } }
          : undefined,
      },
      include: {
        requiredTutorial: true,
      },
    });

    return NextResponse.json(updatedPrerequisite);
  } catch (error) {
    console.error('Error updating prerequisite:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const prerequisiteId = params.id;

  try {
    const prerequisite = await prisma.prerequisite.findUnique({
      where: { id: prerequisiteId },
      include: {
        tutorialSettings: {
          include: {
            tutorial: {
              include: {
                author: true,
              },
            },
          },
        },
      },
    });

    if (!prerequisite) {
      return NextResponse.json({ message: 'Prerequisite not found' }, { status: 404 });
    }

    if (prerequisite.tutorialSettings.tutorial.author.id !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    await prisma.prerequisite.delete({
      where: { id: prerequisiteId },
    });

    return NextResponse.json({ message: 'Prerequisite deleted successfully' });
  } catch (error) {
    console.error('Error deleting prerequisite:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/auth/register/route.ts
import { NextRequest, NextResponse } from 'next/server';
import bcrypt from 'bcrypt';
import prisma from '@/lib/prisma';

export async function POST(request: NextRequest) {
  const { email, password, username } = await request.json();

  try {
    const existingUser = await prisma.user.findUnique({ where: { email } });
    if (existingUser) {
      return NextResponse.json({ message: 'Email already exists.' }, { status: 400 });
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const newUser = await prisma.user.create({
      data: {
        username,
        email,
        passwordHash: hashedPassword,
        firstName: '',
        lastName: '',
        settings: {
          create: {
            emailVerified: false,
            notificationPreferences: {
              create: {
                email: true,
                push: true,
                inApp: true,
              },
            },
            privacySettings: {
              create: {
                profileVisibility: 'PUBLIC',
                activityVisibility: 'PUBLIC',
              },
            },
          },
        },
        profile: {
          create: {},
        },
      },
    });

    return NextResponse.json({ message: 'User registered successfully.' }, { status: 201 });
  } catch (error) {
    console.error('Registration error:', error);
    return NextResponse.json({ message: 'An error occurred during registration.' }, { status: 500 });
  }
}
// app/api/auth/[...nextauth]/route.ts
import authOptions from './options';
import NextAuth from 'next-auth';

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
import { NextAuthOptions } from 'next-auth';
import CredentialsProvider from 'next-auth/providers/credentials';
import prisma, { User } from '@/lib/prisma';
import { compare } from 'bcrypt';

const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: 'Credentials',
      credentials: {
        email: { label: 'Email', type: 'text' },
        password: { label: 'Password', type: 'password' },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          throw new Error('Invalid credentials');
        }

        const user = await prisma.user.findUnique({
          where: {
            email: credentials.email,
          },
          include: {
            profile: true,
            settings: {
              include: {
                notificationPreferences: true,
                privacySettings: true,
              },
            },
          },
        });

        if (!user || !(await compare(credentials.password, user.passwordHash))) {
          throw new Error('Invalid credentials');
        }

        user.id = user.id.toString();

        return user;
      },
    }),
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.user = user;
      }
      return token;
    },
    async session({ session, token }) {
      session.user = token.user as User;
      return session;
    },
  },
  events: {
    async signOut() {
      // Perform any necessary cleanup or additional actions on sign out
    },
  },
  pages: {
    signIn: '/login',
  },
  jwt: {
    secret: process.env.NEXTAUTH_SECRET,
  },
};

export default authOptions;
// app/api/images/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma, { Image } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const imageId = parseInt(params.id);

  try {
    const image = await prisma.image.findUnique({
      where: { id: imageId },
    });

    if (!image) {
      return NextResponse.json({ message: 'Image not found' }, { status: 404 });
    }

    return new NextResponse(image.data, {
      headers: {
        'Content-Type': image.contentType,
        'Cache-Control': 'public, max-age=31536000, immutable',
      },
    });
  } catch (error) {
    console.error('Error fetching image:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  const imageId = parseInt(params.id);
  const { data, contentType } = await request.json();

  try {
    const updatedImage = await prisma.image.update({
      where: { id: imageId },
      data: {
        data,
        contentType,
      },
    });

    return NextResponse.json(updatedImage);
  } catch (error) {
    console.error('Error updating image:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  const imageId = parseInt(params.id);

  try {
    await prisma.image.delete({
      where: { id: imageId },
    });

    return NextResponse.json({ message: 'Image deleted successfully' });
  } catch (error) {
    console.error('Error deleting image:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/projects/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getSession } from '@/lib/auth';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '1');
  const perPage = 10;

  try {
    const totalProjects = await prisma.project.count();
    const totalPages = Math.ceil(totalProjects / perPage);

    const projects = await prisma.project.findMany({
      skip: (page - 1) * perPage,
      take: perPage,
      include: {
        owner: true,
        collaborators: true,
        files: true,
        tags: true,
        comments: true,
        spaces: true,
        bookmarks: true,
        settings: {
          include: {
            visibilitySettings: true,
            collaborationSettings: true,
            notificationSettings: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ projects, totalPages });
  } catch (error) {
    console.error('Error fetching projects:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  const session = await getSession(request);
  const user = session?.user as User;

  if (!session) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { name, description, collaborators, tags, settings } = await request.json();

  try {
    const newProject = await prisma.project.create({
      data: {
        name,
        description,
        owner: { connect: { id: user.id } },
        collaborators: {
          connect: collaborators?.map((collaboratorId: string) => ({ id: collaboratorId })),
        },
        tags: {
          connectOrCreate: tags?.map((tag: string) => ({
            where: { name: tag },
            create: { name: tag },
          })),
        },
        settings: settings
          ? {
              create: {
                visibilitySettings: settings.visibilitySettings
                  ? {
                      create: {
                        visibility: settings.visibilitySettings.visibility,
                      },
                    }
                  : undefined,
                collaborationSettings: settings.collaborationSettings
                  ? {
                      create: {
                        allowCollaborators: settings.collaborationSettings.allowCollaborators,
                        collaboratorRoles: settings.collaborationSettings.collaboratorRoles,
                      },
                    }
                  : undefined,
                notificationSettings: settings.notificationSettings
                  ? {
                      create: {
                        notifyOnActivity: settings.notificationSettings.notifyOnActivity,
                        notifyOnMentions: settings.notificationSettings.notifyOnMentions,
                      },
                    }
                  : undefined,
              },
            }
          : undefined,
      },
    });

    return NextResponse.json(newProject, { status: 201 });
  } catch (error) {
    console.error('Error creating project:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/projects/[id]/comments/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const projectId = params.id;

  try {
    const comments = await prisma.comment.findMany({
      where: { projectId },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        reactions: true,
      },
    });

    return NextResponse.json(comments);
  } catch (error) {
    console.error('Error fetching project comments:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const projectId = params.id;
  const { content, parentId } = await request.json();

  try {
    const newComment = await prisma.comment.create({
      data: {
        content,
        author: { connect: { id: userObj.id } },
        project: { connect: { id: projectId } },
        parent: parentId ? { connect: { id: parentId } } : undefined,
      },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        reactions: true,
      },
    });

    return NextResponse.json(newComment, { status: 201 });
  } catch (error) {
    console.error('Error creating project comment:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/projects/[id]/collaborators/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const projectId = params.id;

  try {
    const collaborators = await prisma.user.findMany({
      where: {
        collaboratedProjects: {
          some: {
            id: projectId,
          },
        },
      },
      select: {
        id: true,
        username: true,
        avatar: true,
      },
    });

    return NextResponse.json(collaborators);
  } catch (error) {
    console.error('Error fetching project collaborators:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const projectId = params.id;
  const { collaboratorId } = await request.json();

  try {
    const project = await prisma.project.findUnique({
      where: { id: projectId },
      include: { owner: true },
    });

    if (!project) {
      return NextResponse.json({ message: 'Project not found' }, { status: 404 });
    }

    if (project.ownerId !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    await prisma.project.update({
      where: { id: projectId },
      data: {
        collaborators: {
          connect: { id: collaboratorId },
        },
      },
    });

    return NextResponse.json({ message: 'Collaborator added successfully' });
  } catch (error) {
    console.error('Error adding project collaborator:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const projectId = params.id;
  const { collaboratorId } = await request.json();

  try {
    const project = await prisma.project.findUnique({
      where: { id: projectId },
      include: { owner: true },
    });

    if (!project) {
      return NextResponse.json({ message: 'Project not found' }, { status: 404 });
    }

    if (project.ownerId !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    await prisma.project.update({
      where: { id: projectId },
      data: {
        collaborators: {
          disconnect: { id: collaboratorId },
        },
      },
    });

    return NextResponse.json({ message: 'Collaborator removed successfully' });
  } catch (error) {
    console.error('Error removing project collaborator:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/projects/[id]/files/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const projectId = params.id;

  try {
    const files = await prisma.file.findMany({
      where: { projectId },
      include: {
        uploadedBy: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        tags: true,
        comments: true,
        parent: true,
        children: true,
        reactions: true,
        bookmarks: true,
        settings: {
          include: {
            uploadLimits: true,
            downloadSettings: true,
            expirationSettings: true,
            versioningSettings: true,
            metadataSettings: true,
          },
        },
      },
    });

    return NextResponse.json(files);
  } catch (error) {
    console.error('Error fetching project files:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const projectId = params.id;
  const { name, description, isPublic, parentId, tags, settings, contentType } = await request.json();

  try {
    const project = await prisma.project.findUnique({
      where: { id: projectId },
      include: { collaborators: true },
    });

    if (!project) {
      return NextResponse.json({ message: 'Project not found' }, { status: 404 });
    }

    if (project.ownerId !== userObj.id && !project.collaborators.some((collaborator) => collaborator.id === userObj.id)) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    const newFile = await prisma.file.create({
      data: {
        name,
        description,
        url: '',
        isPublic,
        contentType,
        project: { connect: { id: projectId } },
        uploadedBy: { connect: { id: userObj.id } },
        parent: parentId ? { connect: { id: parentId } } : undefined,
        tags: tags
          ? {
              connectOrCreate: tags.map((tag: string) => ({
                where: { name: tag },
                create: { name: tag },
              })),
            }
          : undefined,
        settings: settings
          ? {
              create: {
                uploadLimits: {
                  create: {
                    maxFileSize: settings.maxFileSize,
                    allowedFileTypes: settings.allowedFileTypes,
                  },
                },
                downloadSettings: {
                  create: {
                    requireLogin: settings.requireLogin,
                    allowPublicDownload: settings.allowPublicDownload,
                  },
                },
                expirationSettings: {
                  create: {
                    autoDelete: settings.autoDelete,
                    expirationPeriod: settings.expirationPeriod,
                  },
                },
                versioningSettings: {
                  create: {
                    keepVersions: settings.keepVersions,
                  },
                },
                metadataSettings: {
                  create: {
                    allowCustomMetadata: settings.allowCustomMetadata,
                  },
                },
              },
            }
          : undefined,
      },
      include: {
        uploadedBy: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        tags: true,
        comments: true,
        parent: true,
        children: true,
        reactions: true,
        bookmarks: true,
        settings: {
          include: {
            uploadLimits: true,
            downloadSettings: true,
            expirationSettings: true,
            versioningSettings: true,
            metadataSettings: true,
          },
        },
      },
    });

    return NextResponse.json(newFile, { status: 201 });
  } catch (error) {
    console.error('Error creating project file:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/projects/[id]/tags/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const projectId = params.id;

  try {
    const tags = await prisma.tag.findMany({
      where: {
        projects: {
          some: {
            id: projectId,
          },
        },
      },
    });

    return NextResponse.json(tags);
  } catch (error) {
    console.error('Error fetching project tags:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const projectId = params.id;
  const { tags } = await request.json();

  try {
    const project = await prisma.project.findUnique({
      where: { id: projectId },
      include: { owner: true },
    });

    if (!project) {
      return NextResponse.json({ message: 'Project not found' }, { status: 404 });
    }

    if (project.owner.id !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    const updatedProject = await prisma.project.update({
      where: { id: projectId },
      data: {
        tags: {
          connectOrCreate: tags.map((tag: string) => ({
            where: { name: tag },
            create: { name: tag },
          })),
        },
      },
      include: {
        tags: true,
      },
    });

    return NextResponse.json(updatedProject);
  } catch (error) {
    console.error('Error adding project tags:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/projects/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getSession } from '@/lib/auth';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const projectId = params.id;

  try {
    const project = await prisma.project.findUnique({
      where: { id: projectId },
      include: {
        owner: true,
        collaborators: true,
        files: true,
        tags: true,
        comments: true,
        spaces: true,
        bookmarks: true,
        settings: {
          include: {
            visibilitySettings: true,
            collaborationSettings: true,
            notificationSettings: true,
          },
        },
      },
    });

    if (!project) {
      return NextResponse.json({ message: 'Project not found' }, { status: 404 });
    }

    return NextResponse.json(project);
  } catch (error) {
    console.error('Error fetching project:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  const projectId = params.id;
  const session = await getSession(request);
  const user = session?.user as User;

  if (!session) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { name, description, collaborators, tags, settings } = await request.json();

  try {
    const project = await prisma.project.findUnique({
      where: { id: projectId },
      include: { owner: true },
    });

    if (!project) {
      return NextResponse.json({ message: 'Project not found' }, { status: 404 });
    }

    if (project.owner.id !== user.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    const updatedProject = await prisma.project.update({
      where: { id: projectId },
      data: {
        name,
        description,
        collaborators: {
          set: collaborators.map((collaboratorId: string) => ({ id: collaboratorId })),
        },
        tags: {
          set: tags.map((tag: string) => ({ name: tag })),
        },
        settings: settings
          ? {
              update: {
                visibilitySettings: settings.visibilitySettings
                  ? {
                      update: {
                        visibility: settings.visibilitySettings.visibility,
                      },
                    }
                  : undefined,
                collaborationSettings: settings.collaborationSettings
                  ? {
                      update: {
                        allowCollaborators: settings.collaborationSettings.allowCollaborators,
                        collaboratorRoles: settings.collaborationSettings.collaboratorRoles,
                      },
                    }
                  : undefined,
                notificationSettings: settings.notificationSettings
                  ? {
                      update: {
                        notifyOnActivity: settings.notificationSettings.notifyOnActivity,
                        notifyOnMentions: settings.notificationSettings.notifyOnMentions,
                      },
                    }
                  : undefined,
              },
            }
          : undefined,
      },
    });

    return NextResponse.json(updatedProject);
  } catch (error) {
    console.error('Error updating project:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  const projectId = params.id;
  const session = await getSession(request);
  const user = session?.user as User;

  if (!session) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  try {
    const project = await prisma.project.findUnique({
      where: { id: projectId },
      include: { owner: true },
    });

    if (!project) {
      return NextResponse.json({ message: 'Project not found' }, { status: 404 });
    }

    if (project.owner.id !== user.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    await prisma.project.delete({
      where: { id: projectId },
    });

    return NextResponse.json({ message: 'Project deleted successfully' });
  } catch (error) {
    console.error('Error deleting project:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/projects/[id]/files/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const projectId = params.id;

  try {
    const files = await prisma.file.findMany({
      where: { projectId },
      include: {
        uploadedBy: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        tags: true,
        comments: true,
        parent: true,
        children: true,
        reactions: true,
        bookmarks: true,
        settings: {
          include: {
            uploadLimits: true,
            downloadSettings: true,
            expirationSettings: true,
            versioningSettings: true,
            metadataSettings: true,
          },
        },
      },
    });

    return NextResponse.json(files);
  } catch (error) {
    console.error('Error fetching project files:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const projectId = params.id;
  const { name, description, isPublic, parentId, tags, settings, contentType } = await request.json();

  try {
    const project = await prisma.project.findUnique({
      where: { id: projectId },
      include: { collaborators: true },
    });

    if (!project) {
      return NextResponse.json({ message: 'Project not found' }, { status: 404 });
    }

    if (project.ownerId !== userObj.id && !project.collaborators.some((collaborator) => collaborator.id === userObj.id)) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    const newFile = await prisma.file.create({
      data: {
        name,
        description,
        url: '',
        isPublic,
        contentType,
        project: { connect: { id: projectId } },
        uploadedBy: { connect: { id: userObj.id } },
        parent: parentId ? { connect: { id: parentId } } : undefined,
        tags: tags
          ? {
              connectOrCreate: tags.map((tag: string) => ({
                where: { name: tag },
                create: { name: tag },
              })),
            }
          : undefined,
        settings: settings
          ? {
              create: {
                uploadLimits: {
                  create: {
                    maxFileSize: settings.maxFileSize,
                    allowedFileTypes: settings.allowedFileTypes,
                  },
                },
                downloadSettings: {
                  create: {
                    requireLogin: settings.requireLogin,
                    allowPublicDownload: settings.allowPublicDownload,
                  },
                },
                expirationSettings: {
                  create: {
                    autoDelete: settings.autoDelete,
                    expirationPeriod: settings.expirationPeriod,
                  },
                },
                versioningSettings: {
                  create: {
                    keepVersions: settings.keepVersions,
                  },
                },
                metadataSettings: {
                  create: {
                    allowCustomMetadata: settings.allowCustomMetadata,
                  },
                },
              },
            }
          : undefined,
      },
      include: {
        uploadedBy: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        tags: true,
        comments: true,
        parent: true,
        children: true,
        reactions: true,
        bookmarks: true,
        settings: {
          include: {
            uploadLimits: true,
            downloadSettings: true,
            expirationSettings: true,
            versioningSettings: true,
            metadataSettings: true,
          },
        },
      },
    });

    return NextResponse.json(newFile, { status: 201 });
  } catch (error) {
    console.error('Error creating project file:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/activities/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '1');
  const perPage = 10;

  try {
    const totalActivities = await prisma.activity.count({
      where: { userId: userObj.id },
    });
    const totalPages = Math.ceil(totalActivities / perPage);

    const activities = await prisma.activity.findMany({
      where: { userId: userObj.id },
      skip: (page - 1) * perPage,
      take: perPage,
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ activities, totalPages });
  } catch (error) {
    console.error('Error fetching activities:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { activityType, entityId, entityType } = await request.json();

  try {
    const newActivity = await prisma.activity.create({
      data: {
        user: { connect: { id: userObj.id } },
        activityType,
        entityId,
        entityType,
      },
    });

    return NextResponse.json(newActivity, { status: 201 });
  } catch (error) {
    console.error('Error creating activity:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/reactions/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const reactionId = params.id;

  try {
    const reaction = await prisma.commentReaction.findUnique({
      where: { id: reactionId },
    });

    if (!reaction) {
      const fileReaction = await prisma.fileReaction.findUnique({
        where: { id: reactionId },
      });

      if (!fileReaction) {
        return NextResponse.json({ message: 'Reaction not found' }, { status: 404 });
      }

      if (fileReaction.userId !== userObj.id) {
        return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
      }

      await prisma.fileReaction.delete({
        where: { id: reactionId },
      });
    } else {
      if (reaction.userId !== userObj.id) {
        return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
      }

      await prisma.commentReaction.delete({
        where: { id: reactionId },
      });
    }

    return NextResponse.json({ message: 'Reaction deleted successfully' });
  } catch (error) {
    console.error('Error deleting reaction:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/spaces/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getSession } from '@/lib/auth';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '1');
  const perPage = 10;
  const search = searchParams.get('search') || '';

  try {
    const totalSpaces = await prisma.space.count({
      where: {
        OR: [
          { name: { contains: search } },
          { description: { contains: search } },
        ],
      },
    });
    const totalPages = Math.ceil(totalSpaces / perPage);

    const spaces = await prisma.space.findMany({
      where: {
        OR: [
          { name: { contains: search } },
          { description: { contains: search } },
        ],
      },
      skip: (page - 1) * perPage,
      take: perPage,
      include: {
        owner: true,
        collaborators: true,
        pages: true,
        project: true,
        views: true,
        bookmarks: true,
        settings: {
          include: {
            accessControlSettings: true,
            collaborationSettings: true,
            versionControlSettings: true,
            exportSettings: true,
            backupSettings: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ spaces, totalPages });
  } catch (error) {
    console.error('Error fetching spaces:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  const session = await getSession(request);
  const user = session?.user as User;

  if (!session) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { name, description, projectId, collaborators, settings } = await request.json();

  try {
    const newSpace = await prisma.space.create({
      data: {
        name,
        description,
        owner: { connect: { id: user.id } },
        project: projectId ? { connect: { id: projectId } } : undefined,
        collaborators: {
          connect: collaborators.map((collaboratorId: string) => ({ id: collaboratorId })),
        },
        settings: settings
          ? {
              create: {
                accessControlSettings: settings.accessControlSettings
                  ? {
                      create: {
                        visibility: settings.accessControlSettings.visibility,
                        password: settings.accessControlSettings.password,
                      },
                    }
                  : undefined,
                collaborationSettings: settings.collaborationSettings
                  ? {
                      create: {
                        allowCollaborators: settings.collaborationSettings.allowCollaborators,
                        collaboratorRoles: settings.collaborationSettings.collaboratorRoles,
                      },
                    }
                  : undefined,
                versionControlSettings: settings.versionControlSettings
                  ? {
                      create: {
                        enableVersioning: settings.versionControlSettings.enableVersioning,
                        versionNamingConvention: settings.versionControlSettings.versionNamingConvention,
                      },
                    }
                  : undefined,
                exportSettings: settings.exportSettings
                  ? {
                      create: {
                        allowExport: settings.exportSettings.allowExport,
                        exportFormats: settings.exportSettings.exportFormats,
                      },
                    }
                  : undefined,
                backupSettings: settings.backupSettings
                  ? {
                      create: {
                        enableAutoBackup: settings.backupSettings.enableAutoBackup,
                        backupFrequency: settings.backupSettings.backupFrequency,
                      },
                    }
                  : undefined,
              },
            }
          : undefined,
      },
    });

    return NextResponse.json(newSpace, { status: 201 });
  } catch (error) {
    console.error('Error creating space:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/spaces/recently-viewed/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getSession } from '@/lib/auth';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  const session = await getSession(request);
  const user = session?.user as User;

  if (!session) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  try {
    const recentlyViewedSpaces = await prisma.spaceView.findMany({
      where: {
        userId: user.id,
      },
      orderBy: {
        createdAt: 'desc',
      },
      take: 5,
      select: {
        space: {
          include: {
            owner: true,
            project: true,
          },
        },
      },
    });

    const spaces = recentlyViewedSpaces.map((view) => view.space);

    return NextResponse.json(spaces);
  } catch (error) {
    console.error('Error fetching recently viewed spaces:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  const session = await getSession(request);
  const user = session?.user as User;

  if (!session) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { spaceId } = await request.json();

  try {
    const existingView = await prisma.spaceView.findUnique({
      where: {
        spaceId_userId: {
          userId: user.id,
          spaceId,
        },
      },
    });

    if (existingView) {
      await prisma.spaceView.update({
        where: {
          id: existingView.id,
        },
        data: {
          createdAt: new Date(),
        },
      });
    } else {
      await prisma.spaceView.create({
        data: {
          user: { connect: { id: user.id } },
          space: { connect: { id: spaceId } },
        },
      });
    }

    return NextResponse.json({ message: 'Space view recorded successfully' });
  } catch (error) {
    console.error('Error recording space view:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/spaces/[id]/collaborators/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const spaceId = params.id;

  try {
    const collaborators = await prisma.user.findMany({
      where: {
        collaboratedSpaces: {
          some: {
            id: spaceId,
          },
        },
      },
      select: {
        id: true,
        username: true,
        avatar: true,
      },
    });

    return NextResponse.json(collaborators);
  } catch (error) {
    console.error('Error fetching space collaborators:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const spaceId = params.id;
  const { collaboratorId } = await request.json();

  try {
    const space = await prisma.space.findUnique({
      where: { id: spaceId },
      include: { owner: true },
    });

    if (!space) {
      return NextResponse.json({ message: 'Space not found' }, { status: 404 });
    }

    if (space.ownerId !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    await prisma.space.update({
      where: { id: spaceId },
      data: {
        collaborators: {
          connect: { id: collaboratorId },
        },
      },
    });

    return NextResponse.json({ message: 'Collaborator added successfully' });
  } catch (error) {
    console.error('Error adding space collaborator:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const spaceId = params.id;
  const { collaboratorId } = await request.json();

  try {
    const space = await prisma.space.findUnique({
      where: { id: spaceId },
      include: { owner: true },
    });

    if (!space) {
      return NextResponse.json({ message: 'Space not found' }, { status: 404 });
    }

    if (space.ownerId !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    await prisma.space.update({
      where: { id: spaceId },
      data: {
        collaborators: {
          disconnect: { id: collaboratorId },
        },
      },
    });

    return NextResponse.json({ message: 'Collaborator removed successfully' });
  } catch (error) {
    console.error('Error removing space collaborator:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/spaces/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const spaceId = params.id;

  try {
    const space = await prisma.space.findUnique({
      where: { id: spaceId },
      include: {
        owner: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        collaborators: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        pages: true,
        project: true,
        views: true,
        bookmarks: true,
        settings: {
          include: {
            accessControlSettings: true,
            collaborationSettings: true,
            versionControlSettings: true,
            exportSettings: true,
            backupSettings: true,
          },
        },
      },
    });

    if (!space) {
      return NextResponse.json({ message: 'Space not found' }, { status: 404 });
    }

    return NextResponse.json(space);
  } catch (error) {
    console.error('Error fetching space:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const spaceId = params.id;
  const { name, description, projectId, collaborators, settings } = await request.json();

  try {
    const space = await prisma.space.findUnique({
      where: { id: spaceId },
      include: { owner: true },
    });

    if (!space) {
      return NextResponse.json({ message: 'Space not found' }, { status: 404 });
    }

    if (space.owner.id !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    const updatedSpace = await prisma.space.update({
      where: { id: spaceId },
      data: {
        name,
        description,
        project: projectId ? { connect: { id: projectId } } : undefined,
        collaborators: {
          set: collaborators.map((collaboratorId: string) => ({ id: collaboratorId })),
        },
        settings: settings
          ? {
              update: {
                accessControlSettings: settings.accessControlSettings
                  ? {
                      update: {
                        visibility: settings.accessControlSettings.visibility,
                        password: settings.accessControlSettings.password,
                      },
                    }
                  : undefined,
                collaborationSettings: settings.collaborationSettings
                  ? {
                      update: {
                        allowCollaborators: settings.collaborationSettings.allowCollaborators,
                        collaboratorRoles: settings.collaborationSettings.collaboratorRoles,
                      },
                    }
                  : undefined,
                versionControlSettings: settings.versionControlSettings
                  ? {
                      update: {
                        enableVersioning: settings.versionControlSettings.enableVersioning,
                        versionNamingConvention: settings.versionControlSettings.versionNamingConvention,
                      },
                    }
                  : undefined,
                exportSettings: settings.exportSettings
                  ? {
                      update: {
                        allowExport: settings.exportSettings.allowExport,
                        exportFormats: settings.exportSettings.exportFormats,
                      },
                    }
                  : undefined,
                backupSettings: settings.backupSettings
                  ? {
                      update: {
                        enableAutoBackup: settings.backupSettings.enableAutoBackup,
                        backupFrequency: settings.backupSettings.backupFrequency,
                      },
                    }
                  : undefined,
              },
            }
          : undefined,
      },
      include: {
        owner: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        collaborators: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        pages: true,
        project: true,
        views: true,
        bookmarks: true,
        settings: {
          include: {
            accessControlSettings: true,
            collaborationSettings: true,
            versionControlSettings: true,
            exportSettings: true,
            backupSettings: true,
          },
        },
      },
    });

    return NextResponse.json(updatedSpace);
  } catch (error) {
    console.error('Error updating space:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const spaceId = params.id;

  try {
    const space = await prisma.space.findUnique({
      where: { id: spaceId },
      include: { owner: true },
    });

    if (!space) {
      return NextResponse.json({ message: 'Space not found' }, { status: 404 });
    }

    if (space.owner.id !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    await prisma.space.delete({
      where: { id: spaceId },
    });

    return NextResponse.json({ message: 'Space deleted successfully' });
  } catch (error) {
    console.error('Error deleting space:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/spaces/[id]/export/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const spaceId = params.id;
  const format = request.nextUrl.searchParams.get('format');

  try {
    const space = await prisma.space.findUnique({
      where: { id: spaceId },
      include: {
        owner: true,
        collaborators: true,
        pages: true,
      },
    });

    if (!space) {
      return NextResponse.json({ message: 'Space not found' }, { status: 404 });
    }

    if (space.owner.id !== userObj.id && !space.collaborators.some((collaborator) => collaborator.id === userObj.id)) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    // Perform the export based on the specified format
    let exportedData: string;

    switch (format) {
      case 'json':
        exportedData = JSON.stringify(space);
        break;
      case 'markdown':
        // TODO: Convert space data to markdown format
        // ...
        exportedData = '# Markdown export\n\n...';
        break;
      case 'html':
        // TODO: Convert space data to HTML format
        // ...
        exportedData = '<h1>HTML export</h1>\n\n...';
        break;
      default:
        return NextResponse.json({ message: 'Invalid export format' }, { status: 400 });
    }

    return new NextResponse(exportedData, {
      headers: {
        'Content-Type': 'application/octet-stream',
        'Content-Disposition': `attachment; filename="space_${spaceId}.${format}"`,
      },
    });
  } catch (error) {
    console.error('Error exporting space:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/spaces/[id]/import/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const spaceId = params.id;
  const { format, data } = await request.json();

  try {
    const space = await prisma.space.findUnique({
      where: { id: spaceId },
      include: {
        owner: true,
      },
    });

    if (!space) {
      return NextResponse.json({ message: 'Space not found' }, { status: 404 });
    }

    if (space.owner.id !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    // Perform the import based on the specified format
    let importedData;

    switch (format) {
      case 'json':
        importedData = JSON.parse(data);
        break;
      case 'markdown':
        // TODO: Parse markdown data and convert to space data
        // ...
        importedData = { /* parsed space data */ };
        break;
      case 'html':
        // TODO: Parse HTML data and convert to space data
        // ...
        importedData = { /* parsed space data */ };
        break;
      default:
        return NextResponse.json({ message: 'Invalid import format' }, { status: 400 });
    }

    // Update the space with the imported data
    const updatedSpace = await prisma.space.update({
      where: { id: spaceId },
      data: importedData,
    });

    return NextResponse.json(updatedSpace);
  } catch (error) {
    console.error('Error importing space:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/spaces/[id]/views/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const spaceId = params.id;

  try {
    const views = await prisma.spaceView.findMany({
      where: { spaceId },
      include: {
        user: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
      },
    });

    return NextResponse.json(views);
  } catch (error) {
    console.error('Error fetching space views:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const spaceId = params.id;

  try {
    const space = await prisma.space.findUnique({
      where: { id: spaceId },
    });

    if (!space) {
      return NextResponse.json({ message: 'Space not found' }, { status: 404 });
    }

    const existingView = await prisma.spaceView.findUnique({
      where: {
        spaceId_userId: {
          userId: userObj.id,
          spaceId,
        },
      },
    });

    if (existingView) {
      await prisma.spaceView.update({
        where: {
          id: existingView.id,
        },
        data: {
          createdAt: new Date(),
        },
      });
    } else {
      await prisma.spaceView.create({
        data: {
          user: { connect: { id: userObj.id } },
          space: { connect: { id: spaceId } },
        },
      });
    }

    return NextResponse.json({ message: 'Space view recorded successfully' });
  } catch (error) {
    console.error('Error recording space view:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/spaces/[id]/pages/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const spaceId = params.id;

  try {
    const pages = await prisma.page.findMany({
      where: { spaceId },
      include: {
        comments: true,
        bookmarks: true,
        settings: {
          include: {
            seoSettings: true,
            revisionHistorySettings: true,
            commentingSettings: true,
          },
        },
      },
    });

    return NextResponse.json(pages);
  } catch (error) {
    console.error('Error fetching space pages:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const spaceId = params.id;
  const { title, content, settings } = await request.json();

  try {
    const space = await prisma.space.findUnique({
      where: { id: spaceId },
      include: { collaborators: true },
    });

    if (!space) {
      return NextResponse.json({ message: 'Space not found' }, { status: 404 });
    }

    if (space.ownerId !== userObj.id && !space.collaborators.some((collaborator) => collaborator.id === userObj.id)) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    const newPage = await prisma.page.create({
      data: {
        title,
        content,
        space: { connect: { id: spaceId } },
        settings: settings
          ? {
              create: {
                seoSettings: settings.seoSettings
                  ? {
                      create: {
                        metaTitle: settings.seoSettings.metaTitle,
                        metaDescription: settings.seoSettings.metaDescription,
                        openGraphTags: settings.seoSettings.openGraphTags,
                      },
                    }
                  : undefined,
                revisionHistorySettings: settings.revisionHistorySettings
                  ? {
                      create: {
                        revisionsToKeep: settings.revisionHistorySettings.revisionsToKeep,
                      },
                    }
                  : undefined,
                commentingSettings: settings.commentingSettings
                  ? {
                      create: {
                        allowComments: settings.commentingSettings.allowComments,
                        moderateComments: settings.commentingSettings.moderateComments,
                      },
                    }
                  : undefined,
              },
            }
          : undefined,
      },
      include: {
        comments: true,
        bookmarks: true,
        settings: {
          include: {
            seoSettings: true,
            revisionHistorySettings: true,
            commentingSettings: true,
          },
        },
      },
    });

    return NextResponse.json(newPage, { status: 201 });
  } catch (error) {
    console.error('Error creating space page:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getSession } from '@/lib/auth';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  const session = await getSession(request);
  const user = session?.user as User;
  if (!session || user.role !== 'ADMIN') {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }
  const adminSettings = await prisma.adminSettings.findFirst();
  return NextResponse.json(adminSettings);
}

export async function PUT(request: NextRequest) {
  const session = await getSession(request);
  const user = session?.user as User;
  if (!session || user.role !== 'ADMIN') {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }
  const {
    siteTitle,
    siteDescription,
    logo,
    accentColor,
    fileStorageProvider,
    s3AccessKey,
    s3SecretKey,
    s3BucketName,
    s3Region,
    ftpHost,
    ftpUser,
    ftpPassword,
    ftpDirectory,
    maxFileSize,
    allowedFileTypes,
    requireEmailVerification,
    requireAccountApproval,
    enableUserRegistration,
    requireLoginToDownload,
    autoDeleteFiles,
    fileExpirationPeriod,
    enableVersioning,
  } = await request.json();
  try {
    const updatedSettings = await prisma.adminSettings.upsert({
      where: { id: 1 },
      update: {
        siteTitle,
        siteDescription,
        logo,
        accentColor,
        fileStorageProvider,
        s3AccessKey,
        s3SecretKey,
        s3BucketName,
        s3Region,
        ftpHost,
        ftpUser,
        ftpPassword,
        ftpDirectory,
        maxFileSize,
        allowedFileTypes,
        requireEmailVerification,
        requireAccountApproval,
        enableUserRegistration,
        requireLoginToDownload,
        autoDeleteFiles,
        fileExpirationPeriod,
        enableVersioning,
      },
      create: {
        siteTitle,
        siteDescription,
        logo,
        accentColor,
        fileStorageProvider,
        s3AccessKey,
        s3SecretKey,
        s3BucketName,
        s3Region,
        ftpHost,
        ftpUser,
        ftpPassword,
        ftpDirectory,
        maxFileSize,
        allowedFileTypes,
        requireEmailVerification,
        requireAccountApproval,
        enableUserRegistration,
        requireLoginToDownload,
        autoDeleteFiles,
        fileExpirationPeriod,
        enableVersioning,
      },
    });
    return NextResponse.json(updatedSettings);
  } catch (error) {
    console.error('Error updating admin settings:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest) {
  const session = await getSession(request);
  const user = session?.user as User;
  if (!session || user.role !== 'ADMIN') {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }
  try {
    await prisma.adminSettings.delete({
      where: { id: 1 },
    });
    return NextResponse.json({ message: 'Admin settings deleted successfully' });
  } catch (error) {
    console.error('Error deleting admin settings:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/admin/posts/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getSession } from '@/lib/auth';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  const session = await getSession(request);
  const user = session?.user as User;

  if (!session || user.role !== 'ADMIN') {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  try {
    const posts = await prisma.post.findMany({
      take: 5,
      orderBy: {
        createdAt: 'desc',
      },
      include: {
        author: {
          select: {
            id: true,
            username: true,
          },
        },
        tags: true,
        comments: true,
        bookmarks: true,
        settings: {
          include: {
            commentSettings: true,
            sharingSettings: true,
            revisionHistorySettings: true,
          },
        },
      },
    });

    return NextResponse.json(posts);
  } catch (error) {
    console.error('Error fetching posts:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  const session = await getSession(request);
  const user = session?.user as User;

  if (!session || user.role !== 'ADMIN') {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { title, content, authorId, tags, settings } = await request.json();

  try {
    const newPost = await prisma.post.create({
      data: {
        title,
        content,
        author: { connect: { id: authorId } },
        tags: {
          connectOrCreate: tags.map((tag: string) => ({
            where: { name: tag },
            create: { name: tag },
          })),
        },
        settings: settings
          ? {
              create: {
                defaultVisibility: settings.defaultVisibility,
                commentSettings: settings.commentSettings
                  ? {
                      create: {
                        allowComments: settings.commentSettings.allowComments,
                        moderateComments: settings.commentSettings.moderateComments,
                        comment: settings.commentSettings.comment,
                      },
                    }
                  : undefined,
                sharingSettings: settings.sharingSettings
                  ? {
                      create: {
                        allowSharing: settings.sharingSettings.allowSharing,
                        sharePlatforms: settings.sharingSettings.sharePlatforms,
                      },
                    }
                  : undefined,
                revisionHistorySettings: settings.revisionHistorySettings
                  ? {
                      create: {
                        revisionsToKeep: settings.revisionHistorySettings.revisionsToKeep,
                      },
                    }
                  : undefined,
              },
            }
          : undefined,
      },
    });

    return NextResponse.json(newPost, { status: 201 });
  } catch (error) {
    console.error('Error creating post:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/users/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

const secret = process.env.NEXTAUTH_SECRET;

export async function GET(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj || !(userObj.role === 'ADMIN')) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  try {
    const user = await prisma.user.findUnique({
      where: { email: userObj.email },
      select: {
        id: true,
        username: true,
        email: true,
        avatar: true,
        bio: true,
      },
    });

    if (!user) {
      return NextResponse.json({ message: 'User not found' }, { status: 404 });
    }

    return NextResponse.json(user);
  } catch (error) {
    console.error('Error fetching user:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/admin/users/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getSession } from '@/lib/auth';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const user = session?.user as User;

  if (!session || user.role !== 'ADMIN') {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;

  try {
    const userDetails = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        profile: true,
        settings: {
          include: {
            notificationPreferences: true,
            privacySettings: true,
            passwordResetSettings: true,
            accountDeletionSettings: true,
          },
        },
        posts: true,
        comments: true,
        files: true,
        ownedProjects: true,
        collaboratedProjects: true,
        spaces: true,
        collaboratedSpaces: true,
        tutorials: true,
        collaboratedTutorials: true,
      },
    });

    if (!userDetails) {
      return NextResponse.json({ message: 'User not found' }, { status: 404 });
    }

    return NextResponse.json(userDetails);
  } catch (error) {
    console.error('Error fetching user details:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const user = session?.user as User;

  if (!session || user.role !== 'ADMIN') {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;
  const { username, firstName, lastName, email, bio, avatar, role } = await request.json();

  try {
    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: {
        username,
        firstName,
        lastName,
        email,
        bio,
        avatar,
        role,
        profile: {
          update: {
            bio,
          },
        },
      },
      include: {
        profile: true,
        settings: {
          include: {
            notificationPreferences: true,
            privacySettings: true,
            passwordResetSettings: true,
            accountDeletionSettings: true,
          },
        },
      },
    });

    return NextResponse.json(updatedUser);
  } catch (error) {
    console.error('Error updating user:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const user = session?.user as User;

  if (!session || user.role !== 'ADMIN') {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;

  try {
    await prisma.user.delete({
      where: { id: userId },
    });

    return NextResponse.json({ message: 'User deleted successfully' });
  } catch (error) {
    console.error('Error deleting user:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/admin/analytics/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getSession } from '@/lib/auth';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  const session = await getSession(request);
  const user = session?.user as User;

  if (!session || user.role !== 'ADMIN') {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  try {
    const [totalUsers, totalPosts, totalProjects, totalFiles, totalSpaces, totalTutorials] = await Promise.all([
      prisma.user.count(),
      prisma.post.count(),
      prisma.project.count(),
      prisma.file.count(),
      prisma.space.count(),
      prisma.tutorial.count(),
    ]);

    const analytics = {
      totalUsers,
      totalPosts,
      totalProjects,
      totalFiles,
      totalSpaces,
      totalTutorials,
    };

    return NextResponse.json(analytics);
  } catch (error) {
    console.error('Error fetching analytics:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/user/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma, { User } from '@/lib/prisma';
import { uploadImage } from '@/lib/uploadImage';


export async function GET(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!session) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  try {
    const user = await prisma.user.findUnique({
      where: { id: userObj.id },
      include: {
        profile: true,
        settings: {
          include: {
            notificationPreferences: true,
            privacySettings: true,
            passwordResetSettings: true,
            accountDeletionSettings: true,
          },
        },
      },
    });

    if (!user) {
      return NextResponse.json({ message: 'User not found' }, { status: 404 });
    }

    return NextResponse.json(user);
  } catch (error) {
    console.error('User data fetch error:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function PUT(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!session) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }
  const data = await request.formData();
  const username = data.get('username') as string;
  const firstName = data.get('firstName') as string || '';
  const lastName = data.get('lastName') as string || '';
  const email = data.get('email') as string;
  const bio = data.get('bio') as string || '';
  const avatar = data.get('avatar') as File || null;

  let avatarUrl;
  if (avatar) {
    try {
      avatarUrl = await uploadImage(avatar);
    } catch (error) {
      console.error('Error uploading avatar:', error);
      return NextResponse.json({ message: 'Failed to upload avatar' }, { status: 500 });
    }
  }
  
  try {
    const updatedUser = await prisma.user.update({
      where: { id: userObj.id },
      data: {
        username: username.toLowerCase(),
        firstName,
        lastName,
        email,
        bio,
        avatar: avatarUrl,
        profile: {
          update: {
            bio,
          },
        },
      },
    });

    return NextResponse.json(updatedUser);
  } catch (error) {
    console.error('Error updating user:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/tags/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';

export async function GET(request: NextRequest) {
  try {
    const tags = await prisma.tag.findMany({
      include: {
        posts: true,
        files: true,
        projects: true,
        tutorials: true,
      },
    });

    return NextResponse.json(tags);
  } catch (error) {
    console.error('Error fetching tags:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  const { name } = await request.json();

  try {
    const newTag = await prisma.tag.create({
      data: {
        name,
      },
    });

    return NextResponse.json(newTag, { status: 201 });
  } catch (error) {
    console.error('Error creating tag:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/tags/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const tagId = params.id;

  try {
    const tag = await prisma.tag.findUnique({
      where: { id: tagId },
      include: {
        posts: true,
        files: true,
        projects: true,
        tutorials: true,
      },
    });

    if (!tag) {
      return NextResponse.json({ message: 'Tag not found' }, { status: 404 });
    }

    return NextResponse.json(tag);
  } catch (error) {
    console.error('Error fetching tag:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  const tagId = params.id;
  const { name } = await request.json();

  try {
    const updatedTag = await prisma.tag.update({
      where: { id: tagId },
      data: {
        name,
      },
    });

    return NextResponse.json(updatedTag);
  } catch (error) {
    console.error('Error updating tag:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  const tagId = params.id;

  try {
    await prisma.tag.delete({
      where: { id: tagId },
    });

    return NextResponse.json({ message: 'Tag deleted successfully' });
  } catch (error) {
    console.error('Error deleting tag:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/search/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const query = searchParams.get('q') || '';
  const page = parseInt(searchParams.get('page') || '1');
  const perPage = 20;

  try {
    const [posts, files, projects, spaces, tutorials, users] = await Promise.all([
      prisma.post.findMany({
        where: {
          OR: [
            { title: { contains: query, mode: 'insensitive' } },
            { content: { contains: query, mode: 'insensitive' } },
            { author: { username: { contains: query, mode: 'insensitive' } } },
          ],
        },
        select: {
          id: true,
          title: true,
          content: true,
          author: {
            select: {
              id: true,
              username: true,
              avatar: true,
            },
          },
          tags: true,
        },
        skip: (page - 1) * perPage,
        take: perPage,
      }),
      prisma.file.findMany({
        where: {
          OR: [
            { name: { contains: query, mode: 'insensitive' } },
            { description: { contains: query, mode: 'insensitive' } },
            { uploadedBy: { username: { contains: query, mode: 'insensitive' } } },
          ],
        },
        select: {
          id: true,
          name: true,
          description: true,
          uploadedBy: {
            select: {
              id: true,
              username: true,
              avatar: true,
            },
          },
          tags: true,
        },
        skip: (page - 1) * perPage,
        take: perPage,
      }),
      prisma.project.findMany({
        where: {
          OR: [
            { name: { contains: query, mode: 'insensitive' } },
            { description: { contains: query, mode: 'insensitive' } },
            { owner: { username: { contains: query, mode: 'insensitive' } } },
          ],
        },
        select: {
          id: true,
          name: true,
          description: true,
          owner: {
            select: {
              id: true,
              username: true,
              avatar: true,
            },
          },
          tags: true,
        },
        skip: (page - 1) * perPage,
        take: perPage,
      }),
      prisma.space.findMany({
        where: {
          OR: [
            { name: { contains: query, mode: 'insensitive' } },
            { description: { contains: query, mode: 'insensitive' } },
            { owner: { username: { contains: query, mode: 'insensitive' } } },
          ],
        },
        select: {
          id: true,
          name: true,
          description: true,
          owner: {
            select: {
              id: true,
              username: true,
              avatar: true,
            },
          },
        },
        skip: (page - 1) * perPage,
        take: perPage,
      }),
      prisma.tutorial.findMany({
        where: {
          OR: [
            { title: { contains: query, mode: 'insensitive' } },
            { content: { contains: query, mode: 'insensitive' } },
            { author: { username: { contains: query, mode: 'insensitive' } } },
          ],
        },
        select: {
          id: true,
          title: true,
          content: true,
          author: {
            select: {
              id: true,
              username: true,
              avatar: true,
            },
          },
          tags: true,
        },
        skip: (page - 1) * perPage,
        take: perPage,
      }),
      prisma.user.findMany({
        where: {
          OR: [
            { username: { contains: query, mode: 'insensitive' } },
            { firstName: { contains: query, mode: 'insensitive' } },
            { lastName: { contains: query, mode: 'insensitive' } },
          ],
        },
        select: {
          id: true,
          username: true,
          firstName: true,
          lastName: true,
          avatar: true,
          bio: true,
        },
        skip: (page - 1) * perPage,
        take: perPage,
      }),
    ]);

    const results = {
      posts: posts.map((post) => ({
        id: post.id,
        type: 'post',
        title: post.title,
        content: post.content || '',
        url: `/explore/posts/${post.id}`,
      })),
      files: files.map((file) => ({
        id: file.id,
        type: 'file',
        title: file.name,
        content: file.description || '',
        url: `/files/${file.id}`,
      })),
      projects: projects.map((project) => ({
        id: project.id,
        type: 'project',
        title: project.name,
        content: project.description || '',
        url: `/projects/${project.id}`,
      })),
      spaces: spaces.map((space) => ({
        id: space.id,
        type: 'space',
        title: space.name,
        content: space.description || '',
        url: `/spaces/${space.id}`,
      })),
      tutorials: tutorials.map((tutorial) => ({
        id: tutorial.id,
        type: 'tutorial',
        title: tutorial.title,
        content: tutorial.content || '',
        url: `/tutorials/${tutorial.id}`,
      })),
      users: users.map((user) => ({
        id: user.id,
        type: 'user',
        title: `${user.username}`,
        content: user.bio || '',
        url: `/profile/${user.username}`,
        image: user.avatar,
      })),
    };

    console.log(results);

    const totalResults = await prisma.post.count({
      where: {
        OR: [
          { title: { contains: query } },
          { content: { contains: query } },
        ],
      },
    }) + await prisma.file.count({
      where: {
        OR: [
          { name: { contains: query } },
          { description: { contains: query } },
        ],
      },
    }) + await prisma.project.count({
      where: {
        OR: [
          { name: { contains: query } },
          { description: { contains: query } },
        ],
      },
    }) + await prisma.space.count({
      where: {
        OR: [
          { name: { contains: query } },
          { description: { contains: query } },
        ],
      },
    }) + await prisma.tutorial.count({
      where: {
        OR: [
          { title: { contains: query } },
          { content: { contains: query } },
        ],
      },
    });
    const totalPages = Math.ceil(totalResults / perPage);

    return NextResponse.json({
      results
    });
  } catch (error) {
    console.error('Error searching:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/bookmarks/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '1');
  const perPage = 10;

  try {
    const totalBookmarks = await prisma.bookmark.count({
      where: { userId: userObj.id },
    });
    const totalPages = Math.ceil(totalBookmarks / perPage);

    const bookmarks = await prisma.bookmark.findMany({
      where: { userId: userObj.id },
      skip: (page - 1) * perPage,
      take: perPage,
      include: {
        post: {
          include: {
            author: {
              select: {
                id: true,
                username: true,
                avatar: true,
              },
            },
            tags: true,
          },
        },
        file: {
          include: {
            uploadedBy: {
              select: {
                id: true,
                username: true,
                avatar: true,
              },
            },
            tags: true,
          },
        },
        project: {
          include: {
            owner: {
              select: {
                id: true,
                username: true,
                avatar: true,
              },
            },
            tags: true,
          },
        },
        space: {
          include: {
            owner: {
              select: {
                id: true,
                username: true,
                avatar: true,
              },
            },
          },
        },
        page: {
          include: {
            space: {
              include: {
                owner: {
                  select: {
                    id: true,
                    username: true,
                    avatar: true,
                  },
                },
              },
            },
          },
        },
        tutorial: {
          include: {
            author: {
              select: {
                id: true,
                username: true,
                avatar: true,
              },
            },
            tags: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ bookmarks, totalPages });
  } catch (error) {
    console.error('Error fetching bookmarks:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { postId, fileId, projectId, spaceId, pageId, tutorialId } = await request.json();

  try {
    const newBookmark = await prisma.bookmark.create({
      data: {
        user: { connect: { id: userObj.id } },
        post: postId ? { connect: { id: postId } } : undefined,
        file: fileId ? { connect: { id: fileId } } : undefined,
        project: projectId ? { connect: { id: projectId } } : undefined,
        space: spaceId ? { connect: { id: spaceId } } : undefined,
        page: pageId ? { connect: { id: pageId } } : undefined,
        tutorial: tutorialId ? { connect: { id: tutorialId } } : undefined,
      },
    });

    return NextResponse.json(newBookmark, { status: 201 });
  } catch (error) {
    console.error('Error creating bookmark:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/bookmarks/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const bookmarkId = params.id;

  try {
    const bookmark = await prisma.bookmark.findUnique({
      where: { id: bookmarkId },
      include: {
        post: {
          include: {
            author: {
              select: {
                id: true,
                username: true,
                avatar: true,
              },
            },
            tags: true,
          },
        },
        file: {
          include: {
            uploadedBy: {
              select: {
                id: true,
                username: true,
                avatar: true,
              },
            },
            tags: true,
          },
        },
        project: {
          include: {
            owner: {
              select: {
                id: true,
                username: true,
                avatar: true,
              },
            },
            tags: true,
          },
        },
        space: {
          include: {
            owner: {
              select: {
                id: true,
                username: true,
                avatar: true,
              },
            },
          },
        },
        page: {
          include: {
            space: {
              include: {
                owner: {
                  select: {
                    id: true,
                    username: true,
                    avatar: true,
                  },
                },
              },
            },
          },
        },
        tutorial: {
          include: {
            author: {
              select: {
                id: true,
                username: true,
                avatar: true,
              },
            },
            tags: true,
          },
        },
      },
    });

    if (!bookmark || bookmark.userId !== userObj.id) {
      return NextResponse.json({ message: 'Bookmark not found' }, { status: 404 });
    }

    return NextResponse.json(bookmark);
  } catch (error) {
    console.error('Error fetching bookmark:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const bookmarkId = params.id;

  try {
    const bookmark = await prisma.bookmark.findUnique({
      where: { id: bookmarkId },
    });

    if (!bookmark || bookmark.userId !== userObj.id) {
      return NextResponse.json({ message: 'Bookmark not found' }, { status: 404 });
    }

    await prisma.bookmark.delete({
      where: { id: bookmarkId },
    });

    return NextResponse.json({ message: 'Bookmark deleted successfully' });
  } catch (error) {
    console.error('Error deleting bookmark:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
import Anthropic from '@anthropic-ai/sdk';
import { AnthropicStream, StreamingTextResponse } from 'ai';
import { experimental_buildAnthropicPrompt } from 'ai/prompts';
 
// Create an Anthropic API client (that's edge friendly??)
const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY || '',
});
 
// IMPORTANT! Set the runtime to edge
export const runtime = 'edge';
 
export async function POST(req: Request) {
  // Extract the `prompt` from the body of the request
  const { messages } = await req.json();
 
  // Ask Claude for a streaming chat completion given the prompt
  const response = await anthropic.completions.create({
    prompt: experimental_buildAnthropicPrompt(messages),
    model: 'claude-3-opus',
    stream: true,
    max_tokens_to_sample: 1000,
  });
  // Convert the response into a friendly text-stream
  const stream = AnthropicStream(response);
  // Respond with the stream
  return new StreamingTextResponse(stream);
}
// app/api/users/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getSession } from '@/lib/auth';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  try {
    const users = await prisma.user.findMany({
      select: {
        id: true,
        username: true,
        email: true,
        firstName: true,
        lastName: true,
        avatar: true,
        role: true,
        profile: true,
      },
    });

    return NextResponse.json(users);
  } catch (error) {
    console.error('Error fetching users:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/users/[id]/followers/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;

  try {
    const followers = await prisma.user.findUnique({
      where: { id: userId },
      select: {
        followedBy: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
      },
    });

    return NextResponse.json(followers);
  } catch (error) {
    console.error('Error fetching user followers:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/users/[id]/settings/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;

  try {
    const settings = await prisma.userSettings.findUnique({
      where: { userId },
      include: {
        notificationPreferences: true,
        privacySettings: true,
        passwordResetSettings: true,
        accountDeletionSettings: true,
      },
    });

    return NextResponse.json(settings);
  } catch (error) {
    console.error('Error fetching user settings:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;
  const {
    notificationPreferences,
    privacySettings,
    languagePreference,
    themePreference,
    emailVerified,
    passwordResetSettings,
    accountDeletionSettings,
  } = await request.json();

  try {
    const updatedSettings = await prisma.userSettings.update({
      where: { userId },
      data: {
        notificationPreferences: notificationPreferences
          ? {
              update: {
                email: notificationPreferences.email,
                push: notificationPreferences.push,
                inApp: notificationPreferences.inApp,
              },
            }
          : undefined,
        privacySettings: privacySettings
          ? {
              update: {
                profileVisibility: privacySettings.profileVisibility,
                activityVisibility: privacySettings.activityVisibility,
              },
            }
          : undefined,
        languagePreference,
        themePreference,
        emailVerified,
        passwordResetSettings: passwordResetSettings
          ? {
              update: passwordResetSettings,
            }
          : undefined,
        accountDeletionSettings: accountDeletionSettings
          ? {
              update: accountDeletionSettings,
            }
          : undefined,
      },
      include: {
        notificationPreferences: true,
        privacySettings: true,
        passwordResetSettings: true,
        accountDeletionSettings: true,
      },
    });

    return NextResponse.json(updatedSettings);
  } catch (error) {
    console.error('Error updating user settings:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/users/[id]/comments/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;

  try {
    const comments = await prisma.comment.findMany({
      where: { authorId: userId },
      include: {
        post: true,
        file: true,
        project: true,
        page: true,
        parent: true,
        children: true,
        reactions: true,
        settings: {
          include: {
            moderationSettings: true,
            threadingSettings: true,
            votingSettings: true,
          },
        },
      },
    });

    return NextResponse.json(comments);
  } catch (error) {
    console.error('Error fetching user comments:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/users/[id]/posts/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;

  try {
    const posts = await prisma.post.findMany({
      where: {
        authorId: userId,
      },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        tags: true,
        comments: true,
        bookmarks: true,
        settings: {
          include: {
            commentSettings: true,
            sharingSettings: true,
            revisionHistorySettings: true,
          },
        },
      },
    });

    return NextResponse.json(posts);
  } catch (error) {
    console.error('Error fetching user posts:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/users/[id]/collaborators/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
    const session = await getSession(request);
    const userObj = session?.user as User;

    if (!userObj) {
        return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
    }

    const userId = params.id;

    try {
        const collaborators = await prisma.user.findUnique({
            where: { id: userId },
            select: {
                collaboratedProjects: {
                    select: {
                        collaborators: {
                            select: {
                                id: true,
                                username: true,
                                avatar: true,
                            },
                        },
                    },
                },
                collaboratedSpaces: {
                    select: {
                        collaborators: {
                            select: {
                                id: true,
                                username: true,
                                avatar: true,
                            },
                        },
                    },
                },
                collaboratedTutorials: {
                    select: {
                        collaborators: {
                            select: {
                                id: true,
                                username: true,
                                avatar: true,
                            },
                        },
                    },
                },
            },
        });

        const projectCollaborators = (collaborators?.collaboratedProjects.flatMap(
            (project) => project.collaborators
        )) || [];
        const spaceCollaborators = (collaborators?.collaboratedSpaces.flatMap(
            (space) => space.collaborators
        )) || [];
        const tutorialCollaborators = (collaborators?.collaboratedTutorials.flatMap(
            (tutorial) => tutorial.collaborators
        )) || [];

        const allCollaborators = [...projectCollaborators, ...spaceCollaborators, ...tutorialCollaborators];
        const uniqueCollaborators = Array.from(
            new Set(allCollaborators.map((collaborator) => JSON.stringify(collaborator)))
        ).map((collaborator) => JSON.parse(collaborator));

        return NextResponse.json(uniqueCollaborators);
    } catch (error) {
        console.error('Error fetching user collaborators:', error);
        return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
    }
}
// app/api/users/[id]/follow/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;

  try {
    const user = await prisma.user.findUnique({
      where: { id: userId },
    });

    if (!user) {
      return NextResponse.json({ message: 'User not found' }, { status: 404 });
    }

    if (user.id === userObj.id) {
      return NextResponse.json({ message: 'Cannot follow yourself' }, { status: 400 });
    }

    await prisma.user.update({
      where: { id: userObj.id },
      data: {
        following: {
          connect: { id: userId },
        },
      },
    });

    return NextResponse.json({ message: 'User followed successfully' });
  } catch (error) {
    console.error('Error following user:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/users/[id]/projects/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;

  try {
    const projects = await prisma.project.findMany({
      where: {
        OR: [
          { ownerId: userId },
          { collaborators: { some: { id: userId } } },
        ],
      },
      include: {
        owner: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        collaborators: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        files: true,
        tags: true,
        comments: true,
        spaces: true,
        bookmarks: true,
        settings: {
          include: {
            visibilitySettings: true,
            collaborationSettings: true,
            notificationSettings: true,
          },
        },
      },
    });

    return NextResponse.json(projects);
  } catch (error) {
    console.error('Error fetching user projects:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/users/[id]/reactions/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;

  try {
    const commentReactions = await prisma.commentReaction.findMany({
      where: { userId },
      include: {
        comment: {
          include: {
            author: {
              select: {
                id: true,
                username: true,
                avatar: true,
              },
            },
            post: true,
            file: true,
            project: true,
            page: true,
          },
        },
      },
    });

    const fileReactions = await prisma.fileReaction.findMany({
      where: { userId },
      include: {
        file: {
          include: {
            uploadedBy: {
              select: {
                id: true,
                username: true,
                avatar: true,
              },
            },
            project: true,
            tags: true,
          },
        },
      },
    });

    return NextResponse.json({ commentReactions, fileReactions });
  } catch (error) {
    console.error('Error fetching user reactions:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/users/[id]/spaces/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;

  try {
    const spaces = await prisma.space.findMany({
      where: {
        OR: [
          { ownerId: userId },
          { collaborators: { some: { id: userId } } },
        ],
      },
      include: {
        owner: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        collaborators: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        pages: true,
        project: true,
        views: true,
        bookmarks: true,
        settings: {
          include: {
            accessControlSettings: true,
            collaborationSettings: true,
            versionControlSettings: true,
            exportSettings: true,
            backupSettings: true,
          },
        },
      },
    });

    return NextResponse.json(spaces);
  } catch (error) {
    console.error('Error fetching user spaces:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/users/[id]/unfollow/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;

  try {
    const user = await prisma.user.findUnique({
      where: { id: userId },
    });

    if (!user) {
      return NextResponse.json({ message: 'User not found' }, { status: 404 });
    }

    await prisma.user.update({
      where: { id: userObj.id },
      data: {
        following: {
          disconnect: { id: userId },
        },
      },
    });

    return NextResponse.json({ message: 'User unfollowed successfully' });
  } catch (error) {
    console.error('Error unfollowing user:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/users/[id]/bookmarks/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;

  try {
    const bookmarks = await prisma.bookmark.findMany({
      where: { userId },
      include: {
        post: {
          include: {
            author: {
              select: {
                id: true,
                username: true,
                avatar: true,
              },
            },
            tags: true,
          },
        },
        file: {
          include: {
            uploadedBy: {
              select: {
                id: true,
                username: true,
                avatar: true,
              },
            },
            tags: true,
          },
        },
        project: {
          include: {
            owner: {
              select: {
                id: true,
                username: true,
                avatar: true,
              },
            },
            tags: true,
          },
        },
        space: {
          include: {
            owner: {
              select: {
                id: true,
                username: true,
                avatar: true,
              },
            },
          },
        },
        page: {
          include: {
            space: {
              include: {
                owner: {
                  select: {
                    id: true,
                    username: true,
                    avatar: true,
                  },
                },
              },
            },
          },
        },
        tutorial: {
          include: {
            author: {
              select: {
                id: true,
                username: true,
                avatar: true,
              },
            },
            tags: true,
          },
        },
      },
    });

    return NextResponse.json(bookmarks);
  } catch (error) {
    console.error('Error fetching user bookmarks:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/users/[id]/profile/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;

  try {
    const profile = await prisma.profile.findUnique({
      where: { userId },
      include: {
        socialLinks: true,
        skills: true,
      },
    });

    return NextResponse.json(profile);
  } catch (error) {
    console.error('Error fetching user profile:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;
  const { bio, location, website, socialLinks, skills } = await request.json();

  try {
    const updatedProfile = await prisma.profile.update({
      where: { userId },
      data: {
        bio,
        location,
        website,
        socialLinks: {
          deleteMany: {},
          createMany: {
            data: socialLinks,
          },
        },
        skills: {
          deleteMany: {},
          createMany: {
            data: skills,
          },
        },
      },
      include: {
        socialLinks: true,
        skills: true,
      },
    });

    return NextResponse.json(updatedProfile);
  } catch (error) {
    console.error('Error updating user profile:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/users/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { username: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;
  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const username = params.username;

  try {
    const user = await prisma.user.findUnique({
      where: { username: username.toLowerCase() },
      include: {
        profile: true,
        settings: {
          include: {
            notificationPreferences: true,
            privacySettings: true,
            passwordResetSettings: true,
            accountDeletionSettings: true,
          },
        },
        posts: {
          include: {
            author: true,
            comments: true,
          },
        },
        comments: true,
        files: {
          include: {
            uploadedBy: true,
          },
        },
        ownedProjects: {
          include:
            { 
              owner: true,
              collaborators: true,
              spaces: true,
            },
        },
        collaboratedProjects: {
          include: {
            owner: true,
            collaborators: true,
            spaces: true,
          },
        },
        spaces: true,
        collaboratedSpaces: {
          include: {
            owner: true,
            collaborators: true,
          },
        },
        tutorials: {
          include: {
            author: true,
            collaborators: true,
          },
        },
        collaboratedTutorials: {
          include: {
            author: true,
            collaborators: true,
          },
        },
        bookmarks: true,
        commentReactions: true,
        fileReactions: true,
        notifications: true,
        activities: true,
      },
    });

    if (!user) {
      return NextResponse.json({ message: 'User not found' }, { status: 404 });
    }

    return NextResponse.json(user);
  } catch (error) {
    console.error('Error fetching user:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/users/[id]/tutorials/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;

  try {
    const tutorials = await prisma.tutorial.findMany({
        where: {
          OR: [
            { authorId: userId },
            { collaborators: { some: { id: userId } } },
          ],
        },
        include: {
          author: {
            select: {
              id: true,
              username: true,
              avatar: true,
            },
          },
          collaborators: {
            select: {
              id: true,
              username: true,
              avatar: true,
            },
          },
          tags: true,
          comments: true,
          bookmarks: true,
          settings: {
            select: {
              difficultyLevel: true,
              prerequisites: true,
            },
          },
        },
    });

    return NextResponse.json(tutorials);
  } catch (error) {
    console.error('Error fetching user tutorials:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/users/[id]/activities/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;

  try {
    const activities = await prisma.activity.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json(activities);
  } catch (error) {
    console.error('Error fetching user activities:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/users/[id]/following/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;

  try {
    const following = await prisma.user.findUnique({
      where: { id: userId },
      select: {
        following: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
      },
    });

    return NextResponse.json(following);
  } catch (error) {
    console.error('Error fetching user following:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/users/[id]/notifications/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;

  try {
    const notifications = await prisma.notification.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      include: {
        settings: {
          include: {
            commentSettings: true,
          },
        },
      },
    });

    return NextResponse.json(notifications);
  } catch (error) {
    console.error('Error fetching user notifications:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const userId = params.id;
  const { notificationIds, isRead } = await request.json();

  try {
    const updatedNotifications = await prisma.notification.updateMany({
      where: {
        id: { in: notificationIds },
        userId,
      },
      data: {
        isRead,
      },
    });

    return NextResponse.json(updatedNotifications);
  } catch (error) {
    console.error('Error updating user notifications:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/files/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getSession } from '@/lib/auth';
import { User, AdminSettings } from '@/lib/prisma';
import { getStorageProvider } from '@/lib/file-storage';

export const maxDuration = 60;

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '1');
  const perPage = 10;
  try {
    const totalFiles = await prisma.file.count();
    const totalPages = Math.ceil(totalFiles / perPage);
    const files = await prisma.file.findMany({
      skip: (page - 1) * perPage,
      take: perPage,
      include: {
        uploadedBy: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        project: true,
        tags: true,
        comments: true,
        parent: true,
        children: true,
        reactions: true,
        bookmarks: true,
        settings: {
          include: {
            uploadLimits: true,
            downloadSettings: true,
            expirationSettings: true,
            versioningSettings: true,
            metadataSettings: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });
    const adminSettings = await prisma.adminSettings.findFirst();
    const storageProvider = await getStorageProvider(adminSettings! as AdminSettings);
    const filesWithUrls = files.map((file) => ({
      ...file,
      url: storageProvider.getFileUrl(file.url),
    }));
    return NextResponse.json({ files: filesWithUrls, totalPages });
  } catch (error) {
    console.error('Error fetching files:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;
  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const formData = await request.formData();
  const files = formData.getAll('file') as File[];
  const { name, description, isPublic, projectId, parentId, tags, contentType } = Object.fromEntries(formData.entries());

  try {
    const adminSettings = await prisma.adminSettings.findFirst();
    if (!adminSettings) {
      return NextResponse.json({ message: 'Admin settings not found' }, { status: 500 });
    }

    const storageProvider = await getStorageProvider(adminSettings as AdminSettings);

    const uploadedFiles = [];

    for (const file of files) {
      const fileUrl = await storageProvider.uploadFile(file);
      const newFile = await prisma.file.create({

        data: {
          name: name as string,
          url: fileUrl,
          contentType: contentType as string,
          description: description as string,
          isPublic: isPublic === 'true',
          project: projectId ? { connect: { id: projectId as string } } : undefined,
          uploadedBy: { connect: { id: userObj.id } },
          parent: parentId ? { connect: { id: parentId as string } } : undefined,
          tags: tags
            ? {
              connectOrCreate: (tags as string).split(',').map((tag) => ({
                where: { name: tag.trim() },
                create: { name: tag.trim() },
              })),
            }
            : undefined,
          settings: {
            create: {
              uploadLimits: {
                create: {
                  maxFileSize: adminSettings.maxFileSize,
                  allowedFileTypes: adminSettings.allowedFileTypes,
                },
              },
              downloadSettings: {
                create: {
                  requireLogin: adminSettings.requireLoginToDownload,
                },
              },
              expirationSettings: {
                create: {
                  autoDelete: adminSettings.autoDeleteFiles,
                  expirationPeriod: adminSettings.fileExpirationPeriod,
                },
              },
              versioningSettings: {
                create: {
                  keepVersions: adminSettings.enableVersioning,
                },
              },
            },
          },
        },
      });
      uploadedFiles.push(newFile);
    }

      return NextResponse.json(uploadedFiles, { status: 201 });
    } catch (error) {
      console.error('Error uploading file:', error);
      return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
    }
  }
// app/api/files/[id]/comments/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const fileId = params.id;

  try {
    const comments = await prisma.comment.findMany({
      where: { fileId },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        reactions: true,
      },
    });

    return NextResponse.json(comments);
  } catch (error) {
    console.error('Error fetching file comments:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const fileId = params.id;
  const { content, parentId } = await request.json();

  try {
    const newComment = await prisma.comment.create({
      data: {
        content,
        author: { connect: { id: userObj.id } },
        file: { connect: { id: fileId } },
        parent: parentId ? { connect: { id: parentId } } : undefined,
      },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        reactions: true,
      },
    });

    return NextResponse.json(newComment, { status: 201 });
  } catch (error) {
    console.error('Error creating file comment:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/files/[id]/reactions/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const fileId = params.id;

  try {
    const reactions = await prisma.fileReaction.findMany({
      where: { fileId },
      include: {
        user: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
      },
    });

    return NextResponse.json(reactions);
  } catch (error) {
    console.error('Error fetching file reactions:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const fileId = params.id;
  const { type } = await request.json();

  try {
    const existingReaction = await prisma.fileReaction.findUnique({
      where: {
        userId_fileId: {
          fileId,
          userId: userObj.id,
        },
      },
    });

    if (existingReaction) {
      await prisma.fileReaction.delete({
        where: {
          id: existingReaction.id,
        },
      });
      return NextResponse.json({ message: 'Reaction removed successfully' });
    } else {
      const newReaction = await prisma.fileReaction.create({
        data: {
          type,
          file: { connect: { id: fileId } },
          user: { connect: { id: userObj.id } },
        },
        include: {
          user: {
            select: {
              id: true,
              username: true,
              avatar: true,
            },
          },
        },
      });
      return NextResponse.json(newReaction, { status: 201 });
    }
  } catch (error) {
    console.error('Error creating file reaction:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/files/[id]/tags/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const fileId = params.id;

  try {
    const tags = await prisma.tag.findMany({
      where: {
        files: {
          some: {
            id: fileId,
          },
        },
      },
    });

    return NextResponse.json(tags);
  } catch (error) {
    console.error('Error fetching file tags:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const fileId = params.id;
  const { tags } = await request.json();

  try {
    const file = await prisma.file.findUnique({
      where: { id: fileId },
      include: { uploadedBy: true },
    });

    if (!file) {
      return NextResponse.json({ message: 'File not found' }, { status: 404 });
    }

    if (file.uploadedBy.id !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    const updatedFile = await prisma.file.update({
      where: { id: fileId },
      data: {
        tags: {
          connectOrCreate: tags.map((tag: string) => ({
            where: { name: tag },
            create: { name: tag },
          })),
        },
      },
      include: {
        tags: true,
      },
    });

    return NextResponse.json(updatedFile);
  } catch (error) {
    console.error('Error adding file tags:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/files/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getSession } from '@/lib/auth';
import { User, AdminSettings, File } from '@/lib/prisma';
import { getStorageProvider } from '@/lib/file-storage';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const fileId = params.id;
  try {
    const [file, adminSettings] = await Promise.all([
      prisma.file.findUnique({
        where: {
          id: fileId,
        },
        include: {
          uploadedBy: {
            select: {
              id: true,
              username: true,
              avatar: true,
            },
          },
          project: true,
          tags: true,
          comments: true,
          parent: true,
          children: true,
          reactions: true,
          bookmarks: true,
          settings: {
            include: {
              uploadLimits: true,
              downloadSettings: true,
              expirationSettings: true,
              versioningSettings: true,
              metadataSettings: true,
            },
          },
        },
      }),
      prisma.adminSettings.findFirst(),
    ]);
    if (!file) {
      return NextResponse.json({ message: 'File not found' }, { status: 404 });
    }
    const storageProvider = await getStorageProvider(adminSettings! as AdminSettings);
    const fileUrl = storageProvider.getFileUrl(file.url);
    const fileContent = await storageProvider.getFileContent(file.url);

    return NextResponse.json({ ...file, url: fileUrl, content: fileContent });
  } catch (error) {
    console.error('Error fetching file:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  const fileId = params.id;
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  try {
    const [file, adminSettings] = await Promise.all([
      prisma.file.findUnique({
        where: { id: fileId },
        include: { uploadedBy: true, settings: true },
      }),
      prisma.adminSettings.findFirst(),
    ]);

    if (!file) {
      return NextResponse.json({ message: 'File not found' }, { status: 404 });
    }

    if (file.uploadedBy.id !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    const storageProvider = await getStorageProvider(adminSettings! as AdminSettings);
    await storageProvider.deleteFile(file.url);

    // Delete associated records in the appropriate order
    if (file.settings) {
      await prisma.uploadLimits.deleteMany({
        where: { fileSettingsId: file.settings.id },
      });

      await prisma.downloadSettings.deleteMany({
        where: { fileSettingsId: file.settings.id },
      });

      await prisma.expirationSettings.deleteMany({
        where: { fileSettingsId: file.settings.id },
      });

      await prisma.versioningSettings.deleteMany({
        where: { fileSettingsId: file.settings.id },
      });

      await prisma.metadataSettings.deleteMany({
        where: { fileSettingsId: file.settings.id },
      });

      await prisma.fileSettings.delete({
        where: { id: file.settings.id },
      });
    }

    await prisma.comment.deleteMany({
      where: { fileId: fileId },
    });

    await prisma.fileReaction.deleteMany({
      where: { fileId: fileId },
    });

    await prisma.bookmark.deleteMany({
      where: { fileId: fileId },
    });

    await prisma.activity.deleteMany({
      where: {
        entityId: fileId,
        entityType: 'FILE',
      },
    });

    // Delete the file
    await prisma.file.delete({
      where: { id: fileId },
    });

    return NextResponse.json({ message: 'File deleted successfully' });
  } catch (error) {
    console.error('Error deleting file:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/tutorials/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '1');
  const perPage = 10;

  try {
    const totalTutorials = await prisma.tutorial.count();
    const totalPages = Math.ceil(totalTutorials / perPage);

    const tutorials = await prisma.tutorial.findMany({
      skip: (page - 1) * perPage,
      take: perPage,
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        collaborators: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        tags: true,
        comments: true,
        bookmarks: true,
        settings: {
          include: {
            prerequisites: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ tutorials, totalPages });
  } catch (error) {
    console.error('Error fetching tutorials:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { title, content, tags, collaborators, settings } = await request.json();

  try {
    const newTutorial = await prisma.tutorial.create({
      data: {
        title,
        content,
        author: { connect: { id: userObj.id } },
        tags: {
          connectOrCreate: tags.map((tag: string) => ({
            where: { name: tag },
            create: { name: tag },
          })),
        },
        collaborators: {
          connect: collaborators.map((collaboratorId: string) => ({ id: collaboratorId })),
        },
        settings: settings
          ? {
              create: {
                difficultyLevel: settings.difficultyLevel,
                prerequisites: {
                  create: settings.prerequisites.map((prerequisite: any) => ({
                    requiredKnowledge: prerequisite.requiredKnowledge,
                    requiredTutorial: prerequisite.requiredTutorialId
                      ? { connect: { id: prerequisite.requiredTutorialId } }
                      : undefined,
                  })),
                },
              },
            }
          : undefined,
      },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        collaborators: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        tags: true,
        comments: true,
        bookmarks: true,
        settings: {
          include: {
            prerequisites: true,
          },
        },
      },
    });

    return NextResponse.json(newTutorial, { status: 201 });
  } catch (error) {
    console.error('Error creating tutorial:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/tutorials/[id]/unpublish/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const tutorialId = params.id;

  try {
    const tutorial = await prisma.tutorial.findUnique({
      where: { id: tutorialId },
      include: {
        author: true,
      },
    });

    if (!tutorial) {
      return NextResponse.json({ message: 'Tutorial not found' }, { status: 404 });
    }

    if (tutorial.author.id !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    const unpublishedTutorial = await prisma.tutorial.update({
      where: { id: tutorialId },
      data: {
        isPublished: false,
        publishedAt: null,
      },
    });

    return NextResponse.json(unpublishedTutorial);
  } catch (error) {
    console.error('Error unpublishing tutorial:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/tutorials/[id]/collaborators/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const tutorialId = params.id;

  try {
    const collaborators = await prisma.user.findMany({
      where: {
        collaboratedTutorials: {
          some: {
            id: tutorialId,
          },
        },
      },
      select: {
        id: true,
        username: true,
        avatar: true,
      },
    });

    return NextResponse.json(collaborators);
  } catch (error) {
    console.error('Error fetching tutorial collaborators:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const tutorialId = params.id;
  const { collaboratorId } = await request.json();

  try {
    const tutorial = await prisma.tutorial.findUnique({
      where: { id: tutorialId },
      include: { author: true },
    });

    if (!tutorial) {
      return NextResponse.json({ message: 'Tutorial not found' }, { status: 404 });
    }

    if (tutorial.authorId !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    await prisma.tutorial.update({
      where: { id: tutorialId },
      data: {
        collaborators: {
          connect: { id: collaboratorId },
        },
      },
    });

    return NextResponse.json({ message: 'Collaborator added successfully' });
  } catch (error) {
    console.error('Error adding tutorial collaborator:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const tutorialId = params.id;
  const { collaboratorId } = await request.json();

  try {
    const tutorial = await prisma.tutorial.findUnique({
      where: { id: tutorialId },
      include: { author: true },
    });

    if (!tutorial) {
      return NextResponse.json({ message: 'Tutorial not found' }, { status: 404 });
    }

    if (tutorial.authorId !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    await prisma.tutorial.update({
      where: { id: tutorialId },
      data: {
        collaborators: {
          disconnect: { id: collaboratorId },
        },
      },
    });

    return NextResponse.json({ message: 'Collaborator removed successfully' });
  } catch (error) {
    console.error('Error removing tutorial collaborator:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/tutorials/[id]/prerequisites/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const tutorialId = params.id;

  try {
    const prerequisites = await prisma.prerequisite.findMany({
      where: {
        tutorialSettingsId: tutorialId,
      },
      include: {
        requiredTutorial: true,
      },
    });

    return NextResponse.json(prerequisites);
  } catch (error) {
    console.error('Error fetching tutorial prerequisites:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const tutorialId = params.id;
  const { requiredKnowledge, requiredTutorialId } = await request.json();

  try {
    const tutorial = await prisma.tutorial.findUnique({
      where: { id: tutorialId },
      include: { author: true },
    });

    if (!tutorial) {
      return NextResponse.json({ message: 'Tutorial not found' }, { status: 404 });
    }

    if (tutorial.authorId !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    const newPrerequisite = await prisma.prerequisite.create({
      data: {
        requiredKnowledge,
        requiredTutorial: requiredTutorialId ? { connect: { id: requiredTutorialId } } : undefined,
        tutorialSettings: {
          connect: { tutorialId },
        },
      },
    });

    return NextResponse.json(newPrerequisite, { status: 201 });
  } catch (error) {
    console.error('Error adding tutorial prerequisite:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const tutorialId = params.id;
  const { prerequisiteId } = await request.json();

  try {
    const tutorial = await prisma.tutorial.findUnique({
      where: { id: tutorialId },
      include: { author: true },
    });

    if (!tutorial) {
      return NextResponse.json({ message: 'Tutorial not found' }, { status: 404 });
    }

    if (tutorial.authorId !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    await prisma.prerequisite.delete({
      where: { id: prerequisiteId },
    });

    return NextResponse.json({ message: 'Prerequisite removed successfully' });
  } catch (error) {
    console.error('Error removing tutorial prerequisite:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/tutorials/[id]/tags/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const tutorialId = params.id;

  try {
    const tags = await prisma.tag.findMany({
      where: {
        tutorials: {
          some: {
            id: tutorialId,
          },
        },
      },
    });

    return NextResponse.json(tags);
  } catch (error) {
    console.error('Error fetching tutorial tags:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const tutorialId = params.id;
  const { tags } = await request.json();

  try {
    const tutorial = await prisma.tutorial.findUnique({
      where: { id: tutorialId },
      include: { author: true },
    });

    if (!tutorial) {
      return NextResponse.json({ message: 'Tutorial not found' }, { status: 404 });
    }

    if (tutorial.author.id !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    const updatedTutorial = await prisma.tutorial.update({
      where: { id: tutorialId },
      data: {
        tags: {
          connectOrCreate: tags.map((tag: string) => ({
            where: { name: tag },
            create: { name: tag },
          })),
        },
      },
      include: {
        tags: true,
      },
    });

    return NextResponse.json(updatedTutorial);
  } catch (error) {
    console.error('Error adding tutorial tags:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/tutorials/[id]/publish/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const tutorialId = params.id;

  try {
    const tutorial = await prisma.tutorial.findUnique({
      where: { id: tutorialId },
      include: {
        author: true,
      },
    });

    if (!tutorial) {
      return NextResponse.json({ message: 'Tutorial not found' }, { status: 404 });
    }

    if (tutorial.author.id !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    const publishedTutorial = await prisma.tutorial.update({
      where: { id: tutorialId },
      data: {
        isPublished: true,
        publishedAt: new Date(),
      },
    });

    return NextResponse.json(publishedTutorial);
  } catch (error) {
    console.error('Error publishing tutorial:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/tutorials/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const tutorialId = params.id;

  try {
    const tutorial = await prisma.tutorial.findUnique({
      where: { id: tutorialId },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        collaborators: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        tags: true,
        comments: true,
        bookmarks: true,
        settings: {
          include: {
            prerequisites: true,
          },
        },
      },
    });

    if (!tutorial) {
      return NextResponse.json({ message: 'Tutorial not found' }, { status: 404 });
    }

    return NextResponse.json(tutorial);
  } catch (error) {
    console.error('Error fetching tutorial:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const tutorialId = params.id;
  const { title, content, tags, collaborators, settings } = await request.json();

  try {
    const tutorial = await prisma.tutorial.findUnique({
      where: { id: tutorialId },
      include: { author: true },
    });

    if (!tutorial) {
      return NextResponse.json({ message: 'Tutorial not found' }, { status: 404 });
    }

    if (tutorial.author.id !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    const updatedTutorial = await prisma.tutorial.update({
      where: { id: tutorialId },
      data: {
        title,
        content,
        tags: {
          set: tags.map((tag: string) => ({ name: tag })),
        },
        collaborators: {
          set: collaborators.map((collaboratorId: string) => ({ id: collaboratorId })),
        },
        settings: settings
          ? {
              update: {
                difficultyLevel: settings.difficultyLevel,
                prerequisites: {
                  deleteMany: {},
                  create: settings.prerequisites.map((prerequisite: any) => ({
                    requiredKnowledge: prerequisite.requiredKnowledge,
                    requiredTutorial: prerequisite.requiredTutorialId
                      ? { connect: { id: prerequisite.requiredTutorialId } }
                      : undefined,
                  })),
                },
              },
            }
          : undefined,
      },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        collaborators: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        tags: true,
        comments: true,
        bookmarks: true,
        settings: {
          include: {
            prerequisites: true,
          },
        },
      },
    });

    return NextResponse.json(updatedTutorial);
  } catch (error) {
    console.error('Error updating tutorial:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const tutorialId = params.id;

  try {
    const tutorial = await prisma.tutorial.findUnique({
      where: { id: tutorialId },
      include: { author: true },
    });

    if (!tutorial) {
      return NextResponse.json({ message: 'Tutorial not found' }, { status: 404 });
    }

    if (tutorial.author.id !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    await prisma.tutorial.delete({
      where: { id: tutorialId },
    });

    return NextResponse.json({ message: 'Tutorial deleted successfully' });
  } catch (error) {
    console.error('Error deleting tutorial:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/activities/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '1');
  const perPage = 10;

  try {
    const totalActivities = await prisma.activity.count({
      where: { userId: userObj.id },
    });
    const totalPages = Math.ceil(totalActivities / perPage);

    const activities = await prisma.activity.findMany({
      where: { userId: userObj.id },
      skip: (page - 1) * perPage,
      take: perPage,
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ activities, totalPages });
  } catch (error) {
    console.error('Error fetching activities:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { activityType, entityId, entityType } = await request.json();

  try {
    const newActivity = await prisma.activity.create({
      data: {
        user: { connect: { id: userObj.id } },
        activityType,
        entityId,
        entityType,
      },
    });

    return NextResponse.json(newActivity, { status: 201 });
  } catch (error) {
    console.error('Error creating activity:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/pages/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function POST(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { title, content, spaceId } = await request.json();

  try {
    const newPage = await prisma.page.create({
      data: {
        title,
        content,
        space: { connect: { id: spaceId } },
        settings: {
          create: {
            seoSettings: {
              create: {},
            },
            revisionHistorySettings: {
              create: {
                revisionsToKeep: 10,
              },
            },
            commentingSettings: {
              create: {
                allowComments: true,
                moderateComments: false,
              },
            },
          },
        },
      },
      include: {
        space: true,
        comments: true,
        bookmarks: true,
        settings: {
          include: {
            seoSettings: true,
            revisionHistorySettings: true,
            commentingSettings: true,
          },
        },
      },
    });

    return NextResponse.json(newPage, { status: 201 });
  } catch (error) {
    console.error('Error creating page:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/pages/[id]/revert/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const pageId = params.id;
  const { version } = await request.json();

  try {
    const page = await prisma.page.findUnique({
      where: { id: pageId },
      include: {
        space: {
          include: {
            owner: true,
          },
        },
      },
    });

    if (!page) {
      return NextResponse.json({ message: 'Page not found' }, { status: 404 });
    }

    if (page.space.owner.id !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    const versionToRevert = await prisma.page.findFirst({
      where: {
        id: pageId,
        version,
      },
    });

    if (!versionToRevert) {
      return NextResponse.json({ message: 'Version not found' }, { status: 404 });
    }

    const revertedPage = await prisma.page.update({
      where: { id: pageId },
      data: {
        title: versionToRevert.title,
        content: versionToRevert.content,
        version: {
          increment: 1,
        },
      },
    });

    return NextResponse.json(revertedPage);
  } catch (error) {
    console.error('Error reverting page:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/pages/[id]/comments/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const pageId = params.id;

  try {
    const comments = await prisma.comment.findMany({
      where: { pageId },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        reactions: true,
      },
    });

    return NextResponse.json(comments);
  } catch (error) {
    console.error('Error fetching page comments:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const pageId = params.id;
  const { content, parentId } = await request.json();

  try {
    const newComment = await prisma.comment.create({
      data: {
        content,
        author: { connect: { id: userObj.id } },
        page: { connect: { id: pageId } },
        parent: parentId ? { connect: { id: parentId } } : undefined,
      },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar: true,
          },
        },
        reactions: true,
      },
    });

    return NextResponse.json(newComment, { status: 201 });
  } catch (error) {
    console.error('Error creating page comment:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/pages/[id]/versions/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const pageId = params.id;

  try {
    const versions = await prisma.page.findMany({
      where: { id: pageId },
      select: {
        id: true,
        title: true,
        version: true,
        createdAt: true,
        updatedAt: true,
      },
      orderBy: {
        version: 'desc',
      },
    });

    return NextResponse.json(versions);
  } catch (error) {
    console.error('Error fetching page versions:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/pages/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const pageId = params.id;

  try {
    const page = await prisma.page.findUnique({
      where: { id: pageId },
      include: {
        space: true,
        comments: true,
        bookmarks: true,
        settings: {
          include: {
            seoSettings: true,
            revisionHistorySettings: true,
            commentingSettings: true,
          },
        },
      },
    });

    if (!page) {
      return NextResponse.json({ message: 'Page not found' }, { status: 404 });
    }

    return NextResponse.json(page);
  } catch (error) {
    console.error('Error fetching page:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const pageId = params.id;
  const { title, content, settings } = await request.json();

  try {
    const page = await prisma.page.findUnique({
      where: { id: pageId },
      include: { space: true },
    });

    if (!page) {
      return NextResponse.json({ message: 'Page not found' }, { status: 404 });
    }

    if (page.space.ownerId !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    const updatedPage = await prisma.page.update({
      where: { id: pageId },
      data: {
        title,
        content,
        version: { increment: 1 },
        settings: settings
          ? {
              update: {
                seoSettings: settings.seoSettings
                  ? {
                      update: {
                        metaTitle: settings.seoSettings.metaTitle,
                        metaDescription: settings.seoSettings.metaDescription,
                        openGraphTags: settings.seoSettings.openGraphTags,
                      },
                    }
                  : undefined,
                revisionHistorySettings: settings.revisionHistorySettings
                  ? {
                      update: {
                        revisionsToKeep: settings.revisionHistorySettings.revisionsToKeep,
                      },
                    }
                  : undefined,
                commentingSettings: settings.commentingSettings
                  ? {
                      update: {
                        allowComments: settings.commentingSettings.allowComments,
                        moderateComments: settings.commentingSettings.moderateComments,
                      },
                    }
                  : undefined,
              },
            }
          : undefined,
      },
      include: {
        space: true,
        comments: true,
        bookmarks: true,
        settings: {
          include: {
            seoSettings: true,
            revisionHistorySettings: true,
            commentingSettings: true,
          },
        },
      },
    });

    return NextResponse.json(updatedPage);
  } catch (error) {
    console.error('Error updating page:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const pageId = params.id;

  try {
    const page = await prisma.page.findUnique({
      where: { id: pageId },
      include: { space: true },
    });

    if (!page) {
      return NextResponse.json({ message: 'Page not found' }, { status: 404 });
    }

    if (page.space.ownerId !== userObj.id) {
      return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
    }

    await prisma.page.delete({
      where: { id: pageId },
    });

    return NextResponse.json({ message: 'Page deleted successfully' });
  } catch (error) {
    console.error('Error deleting page:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/notifications/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '1');
  const perPage = 10;

  try {
    const totalNotifications = await prisma.notification.count({
      where: { userId: userObj.id },
    });
    const totalPages = Math.ceil(totalNotifications / perPage);

    const notifications = await prisma.notification.findMany({
      where: { userId: userObj.id },
      skip: (page - 1) * perPage,
      take: perPage,
      orderBy: { createdAt: 'desc' },
      include: {
        settings: {
          include: {
            commentSettings: true,
          },
        },
      },
    });

    return NextResponse.json({ notifications, totalPages });
  } catch (error) {
    console.error('Notifications fetch error:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { message, link, settings } = await request.json();

  try {
    const newNotification = await prisma.notification.create({
      data: {
        user: { connect: { id: userObj.id } },
        message,
        link,
        settings: {
          create: {
            channels: settings?.channels || [],
            frequency: settings?.frequency || 'default',
            commentSettings: {
              create: {
                notifyAuthor: settings?.commentSettings?.notifyAuthor || false,
                notifyCommenters: settings?.commentSettings?.notifyCommenters || false,
                comment: settings?.commentSettings?.comment || 'default',
                postSettings: settings?.commentSettings?.postSettings || 'default',
              },
            },
            preferences: settings?.preferences || 'default',
            templates: settings?.templates || 'default',
          },
        },
      },
    });

    
    return NextResponse.json(newNotification, { status: 201 });
  } catch (error) {
    console.error('Error creating notification:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/notifications/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getSession } from '@/lib/auth';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const notificationId = params.id;
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  try {
    const notification = await prisma.notification.findUnique({
      where: { id: notificationId },
      include: {
        settings: {
          include: {
            commentSettings: true,
          },
        },
      },
    });

    if (!notification || notification.userId !== userObj.id) {
      return NextResponse.json({ message: 'Notification not found' }, { status: 404 });
    }

    return NextResponse.json(notification);
  } catch (error) {
    console.error('Error fetching notification:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  const notificationId = params.id;
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { isRead, settings } = await request.json();

  try {
    const notification = await prisma.notification.findUnique({
      where: { id: notificationId },
    });

    if (!notification || notification.userId !== userObj.id) {
      return NextResponse.json({ message: 'Notification not found' }, { status: 404 });
    }

    const updatedNotification = await prisma.notification.update({
      where: { id: notificationId },
      data: {
        isRead,
        settings: settings
          ? {
              update: {
                channels: settings.channels,
                frequency: settings.frequency,
                commentSettings: settings.commentSettings
                  ? {
                      update: {
                        notifyAuthor: settings.commentSettings.notifyAuthor,
                        notifyCommenters: settings.commentSettings.notifyCommenters,
                      },
                    }
                  : undefined,
                preferences: settings.preferences,
                templates: settings.templates,
              },
            }
          : undefined,
      },
      include: {
        settings: {
          include: {
            commentSettings: true,
          },
        },
      },
    });

    return NextResponse.json(updatedNotification);
  } catch (error) {
    console.error('Error updating notification:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  const notificationId = params.id;
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  try {
    const notification = await prisma.notification.findUnique({
      where: { id: notificationId },
    });

    if (!notification || notification.userId !== userObj.id) {
      return NextResponse.json({ message: 'Notification not found' }, { status: 404 });
    }

    await prisma.notification.delete({
      where: { id: notificationId },
    });

    return NextResponse.json({ message: 'Notification deleted successfully' });
  } catch (error) {
    console.error('Error deleting notification:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/onboarding/preferences/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function PUT(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { receiveNotifications, receiveUpdates, languagePreference, themePreference } = await request.json();

  try {
    const updatedUser = await prisma.user.update({
      where: { id: userObj.id },
      data: {
        settings: {
          update: {
            notificationPreferences: {
              update: {
                email: receiveNotifications,
                push: receiveNotifications,
                inApp: receiveNotifications,
              },
            },
            privacySettings: {
              update: {
                profileVisibility: 'PUBLIC',
                activityVisibility: 'PUBLIC',
              },
            },
            languagePreference,
            themePreference,
          },
        },
      },
      include: {
        settings: {
          include: {
            notificationPreferences: true,
            privacySettings: true,
          },
        },
      },
    });

    return NextResponse.json(updatedUser);
  } catch (error) {
    console.error('Error updating preferences:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/onboarding/follow/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function POST(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { type, id } = await request.json();

  try {
    if (type === 'space') {
      await prisma.user.update({
        where: { id: userObj.id },
        data: {
          collaboratedSpaces: {
            connect: { id },
          },
        },
      });
    } else if (type === 'user') {
      await prisma.user.update({
        where: { id: userObj.id },
        data: {
          following: {
            connect: { id },
          },
        },
      });
    } else {
      return NextResponse.json({ message: 'Invalid follow type' }, { status: 400 });
    }

    return NextResponse.json({ message: 'Followed successfully' });
  } catch (error) {
    console.error('Error following:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/onboarding/profile/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';
import { uploadImage } from '@/lib/uploadImage';

export async function PUT(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;
  console.log('userObj:', userObj);
  if (!userObj) {
    return NextResponse.json({ message: 'Not authenticated' }, { status: 401 });
  }

  const formData = await request.formData();
  const username = formData.get('username') as string;
  const firstName = formData.get('firstName') as string;
  const lastName = formData.get('lastName') as string;
  const bio = formData.get('bio') as string;
  const avatar = formData.get('avatar') as File | null;

  let avatarUrl;
  if (avatar) {
    try {
      avatarUrl = await uploadImage(avatar);
    } catch (error) {
      console.error('Error uploading avatar:', error);
      return NextResponse.json({ message: 'Failed to upload avatar' }, { status: 500 });
    }
  }

  try {
    const updatedUser = await prisma.user.update({
      where: { id: userObj.id },
      data: {
        username,
        firstName,
        lastName,
        avatar: avatarUrl,
        bio,
        profile: {
          update: {
            bio,
          },
        },
      },
      include: {
        profile: true,
      },
    });

    return NextResponse.json(updatedUser);
  } catch (error) {
    console.error('Error updating profile:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
// app/api/onboarding/suggestions/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { User } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  const session = await getSession(request);
  const userObj = session?.user as User;

  if (!userObj) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  try {
    const suggestedSpaces = await prisma.space.findMany({
      take: 5,
      select: {
        id: true,
        name: true,
        description: true,
      },
    });

    const suggestedUsers = await prisma.user.findMany({
      take: 5,
      select: {
        id: true,
        username: true,
        avatar: true,
        bio: true,
      },
    });

    return NextResponse.json({ spaces: suggestedSpaces, users: suggestedUsers });
  } catch (error) {
    console.error('Error fetching suggestions:', error);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
